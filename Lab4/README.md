# 实验4.1 - 改进版 UDP数据报收发及转发实验

## 📋 实验环境

| 主机名 | IP地址 | 角色 | 程序文件 | 监听端口 |
|--------|--------|------|----------|----------|
| Camellya | 192.168.10.100 | 发送端 | send_ip.c | - |
| Shorekeeper | 192.168.10.101 | 转发端 | forward_ip.c | 12345 |
| Jinhsi | 192.168.10.102 | 接收端 | recv_ip.c | 54321 |

## ✨ 改进功能

相比原始版本，改进版实现了以下功能：

### 1. 发送端（Camellya）
- ✅ 支持从控制台输入消息
- ✅ 支持发送多条消息（不限数量）
- ✅ 输入 `quit` 或 `exit` 退出程序
- ✅ 显示发送统计信息
- ✅ 自动过滤空消息

### 2. 转发端（Shorekeeper）
- ✅ 持续运行，接收并转发多条消息
- ✅ 显示每条消息的详细信息
- ✅ 支持 Ctrl+C 优雅退出
- ✅ 显示转发统计信息

### 3. 接收端（Jinhsi）
- ✅ 持续运行，接收多条消息
- ✅ 美化的消息显示框
- ✅ 显示时间戳
- ✅ 支持 Ctrl+C 优雅退出
- ✅ 显示接收统计信息

## 🚀 快速开始

### 第一步：传输文件到虚拟机

**使用 scp 命令：**
```bash
# 传输到 Camellya (192.168.10.100)
scp send_ip.c user@192.168.10.100:~/

# 传输到 Shorekeeper (192.168.10.101)
scp forward_ip.c user@192.168.10.101:~/

# 传输到 Jinhsi (192.168.10.102)
scp recv_ip.c user@192.168.10.102:~/
```

### 第二步：编译程序

**在 Camellya 上：**
```bash
gcc -o send_ip send_ip.c
```

**在 Shorekeeper 上：**
```bash
gcc -o forward_ip forward_ip.c
```

**在 Jinhsi 上：**
```bash
gcc -o recv_ip recv_ip.c
```

### 第三步：配置防火墙

**在 Shorekeeper (192.168.10.101) 上：**
```bash
sudo ufw allow 12345/udp
sudo ufw status
```

**在 Jinhsi (192.168.10.102) 上：**
```bash
sudo ufw allow 54321/udp
sudo ufw status
```

### 第四步：按顺序运行程序

**1️⃣ 先在 Jinhsi 启动接收程序：**
```bash
./recv_ip
```
输出示例：
```
===========================================
  UDP 消息接收程序 - 主机 Jinhsi
===========================================
监听端口: 54321
等待接收消息... (按 Ctrl+C 退出)
===========================================
```

**2️⃣ 然后在 Shorekeeper 启动转发程序：**
```bash
./forward_ip
```
输出示例：
```
===========================================
  UDP 消息转发程序 - 主机 Shorekeeper
===========================================
监听端口: 12345 (接收来自 Camellya)
转发目标: 192.168.10.102:54321 (Jinhsi)
等待接收消息... (按 Ctrl+C 退出)
===========================================
```

**3️⃣ 最后在 Camellya 运行发送程序：**
```bash
./send_ip
```
输出示例：
```
===========================================
  UDP 消息发送程序 - 主机 Camellya
===========================================
目标主机: 192.168.10.101:12345 (Shorekeeper)
输入消息进行发送，输入 'quit' 或 'exit' 退出
===========================================

请输入消息 [1]:
```

## 💡 使用示例

### 发送端操作示例

```bash
./send_ip

请输入消息 [1]: Hello World
✓ 消息已发送 [1]: "Hello World" (11 字节)

请输入消息 [2]: This is a test message
✓ 消息已发送 [2]: "This is a test message" (22 字节)

请输入消息 [3]: 你好，这是中文测试
✓ 消息已发送 [3]: "你好，这是中文测试" (27 字节)

请输入消息 [4]: quit

程序退出

===========================================
总共发送了 3 条消息
===========================================
```

### 转发端输出示例

```bash
[消息 1] 收到来自 192.168.10.100:45678
  内容: "Hello World"
  长度: 11 字节
  ✓ 已转发到 192.168.10.102:54321

[消息 2] 收到来自 192.168.10.100:45678
  内容: "This is a test message"
  长度: 22 字节
  ✓ 已转发到 192.168.10.102:54321
```

### 接收端输出示例

```bash
╔═══════════════════════════════════════╗
║ 消息 #1                       [14:35:20] ║
╠═══════════════════════════════════════╣
║ 来源: 192.168.10.101                  ║
║ 端口: 12345                           ║
║ 长度: 11                              ║
╠═══════════════════════════════════════╣
║ 消息内容:                            ║
║ Hello World                           ║
╚═══════════════════════════════════════╝
```

## 🎯 测试场景

### 场景1：基本消息收发
```bash
# 在 Camellya 上
请输入消息 [1]: Hello from Camellya
请输入消息 [2]: Test message 2
请输入消息 [3]: quit
```

### 场景2：中文消息测试
```bash
# 在 Camellya 上
请输入消息 [1]: 你好，世界！
请输入消息 [2]: 这是一条中文测试消息
请输入消息 [3]: quit
```

### 场景3：长消息测试
```bash
# 在 Camellya 上
请输入消息 [1]: This is a very long message to test the buffer size and network transmission capability of UDP protocol...
请输入消息 [2]: quit
```

## 🔧 退出程序

### 发送端 (Camellya)
- 输入 `quit` 或 `exit`
- 或按 `Ctrl+C`

### 转发端 (Shorekeeper)
- 按 `Ctrl+C`

### 接收端 (Jinhsi)
- 按 `Ctrl+C`

## 📊 验证结果

成功运行后，你应该能看到：

1. **Camellya** 显示发送成功并统计发送数量
2. **Shorekeeper** 显示接收并转发每条消息
3. **Jinhsi** 显示接收到的每条消息内容

## ⚠️ 常见问题

### 问题1：消息接收不到
**检查项：**
```bash
# 1. 检查防火墙
sudo ufw status

# 2. 检查网络连通性
ping 192.168.10.101
ping 192.168.10.102

# 3. 检查程序是否正在运行
ps aux | grep send_ip
ps aux | grep forward_ip
ps aux | grep recv_ip
```

### 问题2：编译错误
```bash
# 确保安装了 gcc
sudo apt install build-essential

# 重新编译
gcc -o send_ip send_ip.c
gcc -o forward_ip forward_ip.c
gcc -o recv_ip recv_ip.c
```

### 问题3：中文显示乱码
```bash
# 检查系统语言环境
locale

# 设置 UTF-8 编码
export LANG=zh_CN.UTF-8
export LC_ALL=zh_CN.UTF-8
```

### 问题4：端口被占用
```bash
# 检查端口占用
sudo netstat -tulnp | grep 12345
sudo netstat -tulnp | grep 54321

# 或使用 ss 命令
sudo ss -tulnp | grep 12345
```

## 📈 实验数据记录

建议记录以下信息用于实验报告：

| 测试项 | 发送数量 | 转发数量 | 接收数量 | 备注 |
|--------|----------|----------|----------|------|
| 英文短消息 |  |  |  |  |
| 中文消息 |  |  |  |  |
| 长消息 |  |  |  |  |
| 连续发送 |  |  |  |  |

## 🎓 实验报告要点

1. **实验环境**
   - 三台虚拟机的配置和 IP 地址
   - 网络拓扑图（见 network_topology.md）

2. **程序改进说明**
   - 原程序的局限性
   - 改进后的功能
   - 关键代码解释

3. **运行结果**
   - 三台主机的输出截图
   - 发送、转发、接收的消息数量统计
   - 测试不同类型消息的结果

4. **问题与解决**
   - 遇到的问题
   - 解决方法
   - 经验总结

5. **实验心得**
   - UDP 协议的特点
   - Socket 编程的理解
   - 网络通信的过程

## 🚀 进阶任务

完成基本实验后，可以尝试：

1. **添加消息加密功能**
   - 在发送前加密
   - 在接收后解密

2. **添加消息序号和校验**
   - 添加消息序号
   - 检测丢包情况

3. **支持多个发送端**
   - 修改转发端支持多个发送端
   - 区分不同的发送源

4. **添加图形界面**
   - 使用 ncurses 库
   - 实现更友好的交互界面

## 📚 相关知识点

- UDP 协议特点
- Socket 编程基础
- 信号处理机制
- 网络字节序转换
- 防火墙配置

## 🔗 下一步

完成实验 4.1 后，继续：
- **实验 4.2**：基于单网口主机的 IP 数据报转发及收发（使用原始套接字）
- **实验 4.3**：基于双网口主机的路由转发（实现真正的路由功能）

---

# 实验4.2 - 使用原始套接字的UDP数据报转发实验

## 📋 实验环境

| 主机名 | IP地址 | 角色 | 程序文件 | 监听端口 |
|--------|--------|------|----------|----------|
| Camellya | 192.168.10.100 | 发送端 | send_raw.c | - |
| Shorekeeper | 192.168.10.101 | 转发端 | forward_raw.c | - |
| Jinhsi | 192.168.10.102 | 接收端 | recv_raw.c | 12345 |

## ✨ 实验特点

相比实验4.1，实验4.2的核心区别在于：

### 1. 发送端（Camellya）- send_raw.c
- ✅ 使用 `AF_PACKET` 原始套接字
- ✅ 手动构造完整以太网帧（MAC头 + IP头 + UDP头 + 数据）
- ✅ 需要ROOT权限运行
- ✅ IP头中目标IP为Jinhsi（192.168.10.102）
- ✅ MAC头中目标MAC为Shorekeeper的MAC地址
- ✅ 支持控制台输入多条消息

### 2. 转发端（Shorekeeper）- forward_raw.c
- ✅ 使用 `AF_PACKET` 原始套接字接收数据包
- ✅ 过滤来自Camellya的UDP数据包
- ✅ 修改以太网帧头（更新源/目标MAC地址）
- ✅ 递减IP头的TTL值
- ✅ 重新计算IP头校验和
- ✅ 转发到Jinhsi

### 3. 接收端（Jinhsi）- recv_raw.c
- ✅ 使用标准UDP套接字接收（可以使用标准套接字因为数据包已经是完整的UDP报文）
- ✅ 监听端口12345
- ✅ 美化的消息显示框
- ✅ 显示时间戳

## 🔑 关键概念

### 原始套接字 vs 标准套接字

**标准UDP套接字（实验4.1）**
```
应用程序发送数据 → 内核自动添加UDP头 → 内核自动添加IP头 → 内核自动添加MAC头 → 发送
```

**原始套接字（实验4.2）**
```
应用程序手动构造MAC头 → 应用程序手动构造IP头 → 应用程序手动构造UDP头 → 应用程序填充数据 → 直接发送完整帧
```

### MAC地址与IP地址的不同作用

在实验4.2中：
- **IP头中的目标IP**：192.168.10.102（Jinhsi）- 表示最终目的地
- **MAC头中的目标MAC**：Shorekeeper的MAC - 表示下一跳

这正是路由转发的本质：**IP地址指示最终目标，MAC地址指示下一跳**

## ⚠️ 重要配置

### 1. 查看并配置MAC地址

**在Shorekeeper上查看MAC地址：**
```bash
ip a
# 或
ifconfig
```
找到网卡（如ens33）的MAC地址，然后修改 `send_raw.c` 中的：
```c
#define DEST_MAC0 0x00
#define DEST_MAC1 0x0c
#define DEST_MAC2 0x29
#define DEST_MAC3 0x3e
#define DEST_MAC4 0x1e
#define DEST_MAC5 0x4c
```

**在Jinhsi上查看MAC地址：**
```bash
ip a
```
找到网卡的MAC地址，然后修改 `forward_raw.c` 中的：
```c
#define DEST_MAC0 0x00
#define DEST_MAC1 0x0c
#define DEST_MAC2 0x29
#define DEST_MAC3 0x6d
#define DEST_MAC4 0x5e
#define DEST_MAC5 0x8a
```

### 2. 查看并配置网卡接口名

使用 `ip a` 查看网卡名称，然后修改程序中的：
```c
#define INTERFACE "ens33"  // 改为你的实际网卡名，如eth0、enp0s3等
```

## 🚀 快速开始

### 第一步：传输文件到虚拟机

**使用 scp 命令：**
```bash
# 传输到 Camellya (192.168.10.100)
scp send_raw.c user@192.168.10.100:~/

# 传输到 Shorekeeper (192.168.10.101)
scp forward_raw.c user@192.168.10.101:~/

# 传输到 Jinhsi (192.168.10.102)
scp recv_raw.c user@192.168.10.102:~/
```

### 第二步：编译程序

**在 Camellya 上：**
```bash
gcc -o send_raw send_raw.c
```

**在 Shorekeeper 上：**
```bash
gcc -o forward_raw forward_raw.c
```

**在 Jinhsi 上：**
```bash
gcc -o recv_raw recv_raw.c
```

### 第三步：配置防火墙

**在 Jinhsi (192.168.10.102) 上：**
```bash
sudo ufw allow 12345/udp
sudo ufw status
```

⚠️ **注意**：Shorekeeper使用原始套接字，不需要开放特定UDP端口

### 第四步：按顺序运行程序

**1️⃣ 先在 Jinhsi 启动接收程序：**
```bash
./recv_raw
```
输出示例：
```
===========================================
  UDP 消息接收程序 - 主机 Jinhsi
  (实验4.2 - 原始套接字转发实验)
===========================================
监听端口: 12345
等待接收消息... (按 Ctrl+C 退出)
===========================================
```

**2️⃣ 然后在 Shorekeeper 启动转发程序（需要ROOT权限）：**
```bash
sudo ./forward_raw
```
输出示例：
```
===========================================
  原始套接字转发程序 - Shorekeeper
===========================================
源IP过滤: 192.168.10.100 (Camellya)
目的IP: 192.168.10.102 (Jinhsi)
网卡接口: ens33
⚠️  需要ROOT权限运行！
===========================================
本机MAC地址: 00:0c:29:3e:1e:4c
目标MAC地址: 00:0c:29:6d:5e:8a (Jinhsi)

等待接收数据包... (按 Ctrl+C 退出)
===========================================
```

**3️⃣ 最后在 Camellya 运行发送程序（需要ROOT权限）：**
```bash
sudo ./send_raw
```
输出示例：
```
===========================================
  原始套接字UDP发送程序 - Camellya
===========================================
源IP: 192.168.10.100
目的IP: 192.168.10.102 (Jinhsi)
网卡接口: ens33
⚠️  需要ROOT权限运行！
===========================================
本机MAC地址: 00:0c:29:2a:7b:1c
目标MAC地址: 00:0c:29:3e:1e:4c (Shorekeeper)

输入消息进行发送，输入 'quit' 或 'exit' 退出
===========================================

请输入消息 [1]:
```

## 💡 使用示例

### 发送端操作示例

```bash
sudo ./send_raw

请输入消息 [1]: Hello from raw socket
✓ 数据包已发送 [1]: "Hello from raw socket" (21 字节)
  总帧长度: 63 字节 (ETH:14 + IP:20 + UDP:8 + DATA:21)

请输入消息 [2]: Testing IP forwarding
✓ 数据包已发送 [2]: "Testing IP forwarding" (21 字节)
  总帧长度: 63 字节 (ETH:14 + IP:20 + UDP:8 + DATA:21)

请输入消息 [3]: quit

程序退出

===========================================
总共发送了 2 个数据包
===========================================
```

### 转发端输出示例

```bash
[消息 1] 收到来自 192.168.10.100
  内容: "Hello from raw socket"
  长度: 21 字节
  原TTL: 255
  新TTL: 254
  ✓ 已转发到 192.168.10.102 (00:0c:29:6d:5e:8a)

[消息 2] 收到来自 192.168.10.100
  内容: "Testing IP forwarding"
  长度: 21 字节
  原TTL: 255
  新TTL: 254
  ✓ 已转发到 192.168.10.102 (00:0c:29:6d:5e:8a)
```

### 接收端输出示例

```bash
╔═══════════════════════════════════════╗
║ 消息 #1                       [14:35:20] ║
╠═══════════════════════════════════════╣
║ 来源: 192.168.10.100                  ║
║ 端口: 12345                           ║
║ 长度: 21                              ║
╠═══════════════════════════════════════╣
║ 消息内容:                            ║
║ Hello from raw socket                 ║
╚═══════════════════════════════════════╝
```

## 🔍 使用Wireshark抓包验证

### 在Shorekeeper上抓包

```bash
sudo tcpdump -i ens33 -nn udp port 12345 -v
```

你应该能看到：
1. 来自192.168.10.100的数据包，TTL=255
2. 转发到192.168.10.102的数据包，TTL=254（递减了1）

### 在Jinhsi上抓包

```bash
sudo tcpdump -i ens33 -nn udp port 12345 -v
```

你应该能看到：
- 来自192.168.10.100的数据包（源IP保持不变）
- TTL=254（经过一次转发）

## 🎯 实验验证要点

### 1. 验证MAC地址变化

使用Wireshark观察：
- **Camellya发出的帧**：源MAC=Camellya，目标MAC=Shorekeeper
- **Shorekeeper转发的帧**：源MAC=Shorekeeper，目标MAC=Jinhsi

### 2. 验证IP地址不变

使用tcpdump或Wireshark观察：
- **Camellya发出的包**：源IP=192.168.10.100，目标IP=192.168.10.102
- **Jinhsi收到的包**：源IP=192.168.10.100，目标IP=192.168.10.102（保持不变）

### 3. 验证TTL递减

观察转发前后的TTL值：
- 发送时：TTL=255
- 转发后：TTL=254

## ⚠️ 常见问题

### 问题1：权限错误

```
socket: Operation not permitted
错误：需要ROOT权限！请使用 sudo 运行
```

**解决方案：**
```bash
sudo ./send_raw      # 发送端需要sudo
sudo ./forward_raw   # 转发端需要sudo
./recv_raw           # 接收端不需要sudo
```

### 问题2：找不到网卡接口

```
SIOCGIFINDEX: No such device
错误：找不到网卡接口 ens33
```

**解决方案：**
```bash
# 查看实际的网卡名称
ip a

# 修改程序中的 INTERFACE 定义
#define INTERFACE "你的实际网卡名"  // 如 eth0, enp0s3 等
```

### 问题3：数据包无法到达

**检查步骤：**

1. **验证MAC地址配置**
```bash
# 在每台机器上查看MAC地址
ip a | grep ether
```

2. **检查防火墙**
```bash
# 在Jinhsi上
sudo ufw status
sudo ufw allow 12345/udp
```

3. **使用tcpdump抓包**
```bash
# 在Shorekeeper上
sudo tcpdump -i ens33 -nn 'udp and host 192.168.10.100'

# 在Jinhsi上
sudo tcpdump -i ens33 -nn 'udp port 12345'
```

### 问题4：编译错误

如果遇到头文件缺失：
```bash
# 安装开发工具
sudo apt install build-essential
sudo apt install linux-headers-$(uname -r)
```

## 📊 实验数据记录

建议记录以下信息用于实验报告：

| 阶段 | 源MAC | 目标MAC | 源IP | 目标IP | TTL | 备注 |
|------|-------|---------|------|--------|-----|------|
| Camellya发送 |  |  | 192.168.10.100 | 192.168.10.102 | 255 |  |
| Shorekeeper接收 |  |  | 192.168.10.100 | 192.168.10.102 | 255 |  |
| Shorekeeper转发 |  |  | 192.168.10.100 | 192.168.10.102 | 254 |  |
| Jinhsi接收 |  |  | 192.168.10.100 | 192.168.10.102 | 254 |  |

## 🎓 实验报告要点

1. **实验原理**
   - 原始套接字的工作原理
   - 以太网帧结构（MAC头 + IP头 + UDP头 + 数据）
   - IP转发过程中的TTL递减机制
   - MAC地址与IP地址的作用区别

2. **关键代码解释**
   - 如何创建AF_PACKET原始套接字
   - 如何手动构造以太网帧
   - 如何计算IP头校验和
   - 如何修改和转发数据包

3. **实验现象**
   - 三台主机的输出截图
   - Wireshark抓包截图（显示MAC地址变化）
   - tcpdump输出（显示TTL变化）

4. **对比分析**
   - 实验4.1与4.2的区别
   - 标准套接字 vs 原始套接字
   - 应用层转发 vs 网络层转发

5. **实验心得**
   - 对IP转发机制的理解
   - 对路由器工作原理的认识
   - 遇到的问题和解决过程

## 📚 相关知识点

- AF_PACKET原始套接字
- 以太网帧格式（RFC 894）
- IP数据报格式（RFC 791）
- UDP数据报格式（RFC 768）
- IP校验和计算算法
- TTL（Time To Live）机制
- MAC地址与ARP协议
- 网络字节序（大端序）

## 🔬 深入思考

1. **为什么转发端要修改MAC地址？**
   - MAC地址用于数据链路层寻址，每经过一跳需要更新
   - IP地址用于网络层端到端寻址，保持不变

2. **为什么要递减TTL？**
   - 防止数据包在网络中无限循环
   - TTL=0时路由器丢弃数据包并发送ICMP超时消息

3. **为什么接收端可以使用标准套接字？**
   - 数据包到达时内核已经处理好MAC头和IP头
   - 应用程序只需要接收UDP载荷

4. **如果不重新计算校验和会怎样？**
   - 接收端会检测到校验和错误
   - 数据包会被丢弃

## 🚀 进阶任务

完成基本实验后，可以尝试：

1. **实现ICMP协议**
   - 构造ICMP Echo Request（ping）
   - 接收并解析ICMP Echo Reply

2. **实现多跳转发**
   - 添加第二个转发节点
   - 观察TTL的连续递减

3. **实现简单的路由表**
   - 根据目标IP查找下一跳
   - 动态修改转发目标

4. **添加统计功能**
   - 统计转发速率（包/秒）
   - 计算丢包率
   - 测量转发延迟

## 🔗 下一步

完成实验 4.2 后，继续：
- **实验 4.3**：基于双网口主机的路由转发（使用两块网卡实现真正的路由功能）
- **实验 4.4**：实现RIP路由协议（动态路由）

---

# 实验4.3 - 基于双网口主机的路由转发

## 📋 实验环境

| 主机名 | IP地址 | 子网 | 角色 | 程序文件 | 监听端口 | 网关 |
|--------|--------|------|------|----------|----------|------|
| 源主机 | 192.168.1.2/24 | 网段A | 发送端 | send_dual.c | - | 192.168.1.1 |
| 路由主机 | 192.168.1.1/24 (eth0)<br>192.168.2.1/24 (eth1) | 网段A/B | 路由器 | forward_dual.c | - | - |
| 目的主机 | 192.168.2.2/24 | 网段B | 接收端 | recv_dual.c | 12345 | 192.168.2.1 |

## ✨ 实验特点

相比实验4.2，实验4.3的核心区别在于：

### 1. 真正的路由转发
- ✅ 路由主机具有**两个网络接口**（eth0和eth1）
- ✅ 连接**两个不同的子网**（192.168.1.0/24 和 192.168.2.0/24）
- ✅ 使用**静态路由表**进行转发决策
- ✅ 从一个接口接收，从另一个接口转发

### 2. 发送端（源主机）- send_dual.c
- ✅ 位于192.168.1.0/24子网
- ✅ 使用标准UDP套接字
- ✅ 发送到192.168.2.2（不同子网）
- ✅ 通过网关192.168.1.1转发

### 3. 路由转发端（路由主机）- forward_dual.c
- ✅ 双网口配置（eth0连接网段A，eth1连接网段B）
- ✅ 使用AF_PACKET原始套接字
- ✅ 实现路由表查找功能
- ✅ 递减TTL并重新计算校验和
- ✅ 更新MAC地址（源MAC和目标MAC都要改变）

### 4. 接收端（目的主机）- recv_dual.c
- ✅ 位于192.168.2.0/24子网
- ✅ 使用标准UDP套接字
- ✅ 监听端口12345
- ✅ 显示跨子网通信标识

## 🔑 关键概念

### 双网口路由器工作原理

```
源主机 (192.168.1.2)                    目的主机 (192.168.2.2)
      |                                          |
      | 网段A: 192.168.1.0/24                    | 网段B: 192.168.2.0/24
      |                                          |
    [eth0]                                    [eth1]
      |                                          |
      +------ 路由主机 (192.168.1.1 / 192.168.2.1) ------+
```

**转发过程：**
1. 源主机发送数据包，目标IP=192.168.2.2，通过网关192.168.1.1
2. 路由主机eth0接收数据包
3. 查找路由表，确定应从eth1转发
4. 修改MAC地址，TTL递减，重新计算校验和
5. 从eth1发送到目的主机
6. 目的主机接收数据包

### 路由表结构

```c
struct route_entry {
    uint32_t dest;          // 目的网络
    uint32_t gateway;       // 下一跳（0表示直接交付）
    uint32_t netmask;       // 子网掩码
    char interface[IFNAMSIZ]; // 出接口
};
```

示例路由表：
```
目的网络          子网掩码          下一跳    出接口
192.168.2.0    255.255.255.0    直接交付    eth1
```

## ⚠️ 重要配置

### 1. 配置双网口路由器

**查看网络接口：**
```bash
ip a
```

**配置eth0接口（连接网段A）：**
```bash
sudo ip addr add 192.168.1.1/24 dev eth0
sudo ip link set eth0 up
```

**配置eth1接口（连接网段B）：**
```bash
sudo ip addr add 192.168.2.1/24 dev eth1
sudo ip link set eth1 up
```

**启用IP转发：**
```bash
sudo sysctl -w net.ipv4.ip_forward=1
# 或者
echo 1 | sudo tee /proc/sys/net/ipv4/ip_forward
```

**永久启用IP转发：**
```bash
sudo nano /etc/sysctl.conf
# 添加或取消注释：
# net.ipv4.ip_forward=1
sudo sysctl -p
```

### 2. 配置源主机

**设置IP地址：**
```bash
sudo ip addr add 192.168.1.2/24 dev eth0
```

**配置默认网关：**
```bash
sudo ip route add default via 192.168.1.1
```

**验证路由：**
```bash
ip route show
```

### 3. 配置目的主机

**设置IP地址：**
```bash
sudo ip addr add 192.168.2.2/24 dev eth0
```

**配置默认网关：**
```bash
sudo ip route add default via 192.168.2.1
```

**开放防火墙端口：**
```bash
sudo ufw allow 12345/udp
sudo ufw status
```

### 4. 配置MAC地址

**在路由主机上查看目的主机的MAC地址：**
```bash
# 首先ping目的主机以建立ARP缓存
ping -c 1 192.168.2.2

# 查看ARP表
arp -n
# 或
ip neigh show
```

找到192.168.2.2的MAC地址后，修改 `forward_dual.c` 中的：
```c
unsigned char target_mac[ETH_ALEN] = {0x00, 0x0c, 0x29, 0x48, 0xd3, 0xf7};
```

## 🚀 快速开始

### 第一步：准备三台虚拟机

1. **虚拟机1（源主机）**：单网卡，桥接模式或内部网络
2. **虚拟机2（路由主机）**：**双网卡**，分别连接两个网段
3. **虚拟机3（目的主机）**：单网卡，桥接模式或内部网络

### 第二步：传输文件到虚拟机

```bash
# 传输到源主机
scp send_dual.c user@192.168.1.2:~/

# 传输到路由主机
scp forward_dual.c user@192.168.1.1:~/  # 通过eth0连接

# 传输到目的主机
scp recv_dual.c user@192.168.2.2:~/     # 通过路由主机或单独网络
```

### 第三步：编译程序

**在源主机上：**
```bash
gcc -o send_dual send_dual.c
```

**在路由主机上：**
```bash
gcc -o forward_dual forward_dual.c
```

**在目的主机上：**
```bash
gcc -o recv_dual recv_dual.c
```

### 第四步：配置网络（按顺序）

**1️⃣ 在路由主机上配置双网口：**
```bash
# 配置eth0（连接网段A）
sudo ip addr add 192.168.1.1/24 dev eth0
sudo ip link set eth0 up

# 配置eth1（连接网段B）
sudo ip addr add 192.168.2.1/24 dev eth1
sudo ip link set eth1 up

# 启用IP转发
sudo sysctl -w net.ipv4.ip_forward=1

# 验证配置
ip addr show
```

**2️⃣ 在源主机上配置网关：**
```bash
# 配置IP（如果需要）
sudo ip addr add 192.168.1.2/24 dev eth0

# 配置默认网关
sudo ip route add default via 192.168.1.1

# 测试连通性
ping 192.168.1.1  # 能ping通路由主机
ping 192.168.2.1  # 应该也能ping通（通过路由）
```

**3️⃣ 在目的主机上配置网关：**
```bash
# 配置IP（如果需要）
sudo ip addr add 192.168.2.2/24 dev eth0

# 配置默认网关
sudo ip route add default via 192.168.2.1

# 开放端口
sudo ufw allow 12345/udp

# 测试连通性
ping 192.168.2.1  # 能ping通路由主机
ping 192.168.1.1  # 应该也能ping通（通过路由）
```

### 第五步：运行程序（按顺序）

**1️⃣ 先在目的主机上启动接收程序：**
```bash
./recv_dual
```

**2️⃣ 然后在路由主机上启动转发程序（需要ROOT）：**
```bash
sudo ./forward_dual
```

**3️⃣ 最后在源主机上运行发送程序：**
```bash
./send_dual
```

## 💡 使用示例

### 完整测试流程

**在源主机（192.168.1.2）上：**
```bash
./send_dual

请输入消息 [1]: Hello across subnets!
✓ 消息已发送 [1]: "Hello across subnets!" (21 字节)
  -> 目标: 192.168.2.2:12345 (跨子网通信)

请输入消息 [2]: Testing router
✓ 消息已发送 [2]: "Testing router" (14 字节)
  -> 目标: 192.168.2.2:12345 (跨子网通信)

请输入消息 [3]: quit
```

**在路由主机（192.168.1.1/192.168.2.1）上：**
```bash
sudo ./forward_dual

[14:35:20] [消息 1] 路由转发
  源地址: 192.168.1.2
  目的地址: 192.168.2.2
  原TTL: 64
  新TTL: 63
  出接口: eth1
  ✓ 已转发到 192.168.2.2 (通过 eth1)
  目标MAC: 00:0c:29:48:d3:f7

[14:35:25] [消息 2] 路由转发
  源地址: 192.168.1.2
  目的地址: 192.168.2.2
  原TTL: 64
  新TTL: 63
  出接口: eth1
  ✓ 已转发到 192.168.2.2 (通过 eth1)
  目标MAC: 00:0c:29:48:d3:f7
```

**在目的主机（192.168.2.2）上：**
```bash
./recv_dual

╔═══════════════════════════════════════╗
║ 消息 #1                       [14:35:20] ║
╠═══════════════════════════════════════╣
║ 来源: 192.168.1.2                     ║
║ 端口: 54321                           ║
║ 长度: 21                              ║
║ 类型: 跨子网通信                      ║
╠═══════════════════════════════════════╣
║ 消息内容:                            ║
║ Hello across subnets!                 ║
╚═══════════════════════════════════════╝
```

## 🔍 使用tcpdump验证

### 在路由主机上同时监听两个接口

**终端1 - 监听eth0（接收侧）：**
```bash
sudo tcpdump -i eth0 -nn 'udp and host 192.168.2.2' -v
```

**终端2 - 监听eth1（发送侧）：**
```bash
sudo tcpdump -i eth1 -nn 'udp and host 192.168.2.2' -v
```

你应该能观察到：
- **eth0上**：源MAC=源主机，目标MAC=路由主机eth0，TTL=64
- **eth1上**：源MAC=路由主机eth1，目标MAC=目的主机，TTL=63

## 🎯 实验验证要点

### 1. 验证路由转发

使用traceroute查看数据包路径：
```bash
# 在源主机上
traceroute 192.168.2.2
```

应该看到经过192.168.1.1（路由主机）

### 2. 验证TTL递减

观察路由主机的输出，确认TTL从64变为63

### 3. 验证MAC地址变化

使用Wireshark或tcpdump抓包，观察：
- **源主机发出**：源MAC=源主机，目标MAC=路由主机eth0
- **路由主机eth0接收**：相同的帧
- **路由主机eth1发送**：源MAC=路由主机eth1，目标MAC=目的主机
- **目的主机接收**：来自路由主机eth1的帧

### 4. 验证IP地址保持不变

整个过程中，IP头中的源IP（192.168.1.2）和目标IP（192.168.2.2）保持不变

## ⚠️ 常见问题

### 问题1：找不到第二个网卡

**检查虚拟机网卡配置：**
- VirtualBox: 设置 → 网络 → 网卡2（启用）
- VMware: 编辑虚拟机设置 → 添加 → 网络适配器

**在Linux中检查：**
```bash
ip link show
```

### 问题2：无法ping通不同子网

**检查步骤：**

1. **验证路由主机的IP转发是否启用**
```bash
cat /proc/sys/net/ipv4/ip_forward
# 应该输出 1
```

2. **检查路由表**
```bash
# 在源主机上
ip route show
# 应该有: default via 192.168.1.1 dev eth0

# 在目的主机上
ip route show
# 应该有: default via 192.168.2.1 dev eth0
```

3. **检查防火墙**
```bash
sudo iptables -L -v -n
# 确保没有阻止转发的规则
```

### 问题3：路由程序收不到数据包

**可能原因：**

1. **网卡接口名称不正确**
   - 使用 `ip a` 查看实际接口名
   - 修改代码中的 "eth0", "eth1" 为实际名称（如 "ens33", "ens34"）

2. **没有ROOT权限**
   ```bash
   sudo ./forward_dual
   ```

3. **路由表配置错误**
   - 检查 forward_dual.c 中的路由表配置

### 问题4：虚拟机网络配置

**VirtualBox配置建议：**
- 网卡1（eth0）：内部网络 "intnet1"
- 网卡2（eth1）：内部网络 "intnet2"

**VMware配置建议：**
- 网卡1（eth0）：自定义（VMnet2）
- 网卡2（eth1）：自定义（VMnet3）

## 📊 实验数据记录

建议记录以下信息用于实验报告：

| 位置 | 接口 | 源MAC | 目标MAC | 源IP | 目标IP | TTL | 备注 |
|------|------|-------|---------|------|--------|-----|------|
| 源主机发送 | eth0 |  |  | 192.168.1.2 | 192.168.2.2 | 64 |  |
| 路由主机接收 | eth0 |  |  | 192.168.1.2 | 192.168.2.2 | 64 |  |
| 路由主机转发 | eth1 |  |  | 192.168.1.2 | 192.168.2.2 | 63 | TTL递减 |
| 目的主机接收 | eth0 |  |  | 192.168.1.2 | 192.168.2.2 | 63 |  |

## 🎓 实验报告要点

1. **实验原理**
   - 路由器的工作原理
   - 静态路由表的作用
   - 为什么需要两个网卡
   - MAC地址vs IP地址在路由中的角色

2. **关键代码解释**
   - 路由表查找算法
   - 如何从一个接口接收，另一个接口发送
   - TTL递减的意义
   - 为什么要重新计算校验和

3. **实验现象**
   - 三台主机的输出截图
   - tcpdump抓包结果（两个接口）
   - traceroute路径追踪结果
   - Wireshark分析（显示MAC地址变化）

4. **对比分析**
   - 实验4.2 vs 4.3的区别
   - 单网口转发 vs 双网口路由
   - 同子网通信 vs 跨子网通信

5. **进阶扩展**
   - 如何添加更多路由表项
   - 如何实现ARP协议自动获取MAC地址
   - 如何支持双向通信

## 📚 相关知识点

- 路由器工作原理
- 静态路由配置
- 路由表结构与查找算法
- 子网划分与CIDR
- 默认网关的作用
- 数据包在路由器中的处理流程
- 三层交换vs路由
- Linux IP转发机制

## 🔬 深入思考

1. **为什么路由器需要两个网卡？**
   - 连接两个不同的物理网段
   - 每个网卡属于一个子网
   - 实现不同网段间的通信

2. **为什么IP地址不变但MAC地址要变？**
   - IP地址：端到端寻址（网络层）
   - MAC地址：逐跳寻址（数据链路层）
   - 路由器工作在第三层，需要重新封装第二层

3. **如果没有配置默认网关会怎样？**
   - 源主机不知道如何到达不同子网
   - 数据包无法发送出去
   - 提示"Network is unreachable"

4. **路由表查找是如何工作的？**
   - 最长前缀匹配原则
   - 目标IP & 子网掩码 = 网络地址
   - 匹配路由表中的网络地址

## 🚀 进阶任务

完成基本实验后，可以尝试：

1. **实现双向通信**
   - 在目的主机上发送回复
   - 路由主机需要添加反向路由

2. **添加更多子网**
   - 配置第三个网卡（eth2）
   - 添加第三个子网（192.168.3.0/24）
   - 扩展路由表

3. **实现ARP协议**
   - 自动学习和缓存MAC地址
   - 避免手动配置target_mac

4. **添加路由统计功能**
   - 统计每个接口的转发数量
   - 统计不同子网的流量
   - 记录丢包情况

5. **实现简单的NAT**
   - 修改源IP地址
   - 维护NAT表
   - 实现内网访问外网

## 🔗 下一步

完成实验 4.3 后，可以进一步学习：
- **动态路由协议**：RIP、OSPF
- **路由选择算法**：Dijkstra、Bellman-Ford
- **高级路由特性**：路由策略、QoS
- **软件路由器**：Quagga、FRRouting
