# 实验4.3 增强版 - 双向路由转发

## 概述

本实验是Lab4-3的增强版本，通过完善路由表实现真正的**双向传输**功能。与原版相比，增强版支持完整的双向通信，包括从192.168.1.x到192.168.2.x的转发，以及从192.168.2.x到192.168.1.x的反向转发。

## 主要增强特性

### 1. 完善的双向路由表

增强版路由表包含两个方向的路由条目：

| 目的网络 | 子网掩码 | 出接口 | 描述 |
|---------|---------|--------|------|
| 192.168.2.0 | 255.255.255.0 | eth1 | Forward: 1→2 |
| 192.168.1.0 | 255.255.255.0 | eth0 | Reverse: 2→1 |

### 2. ARP缓存机制

- 动态学习源MAC地址
- 支持静态ARP条目配置
- 避免重复的MAC地址查找

### 3. 真正的双向通信

- **发送端** (`send_dual_enhanced.c`)：
  - 发送消息到目的主机
  - 接收来自目的主机的响应
  - 多线程处理（发送线程 + 接收线程）
  - 测量往返时间（RTT）
  
- **接收端** (`recv_dual_enhanced.c`)：
  - 接收来自源主机的消息
  - 自动回复确认消息
  - 实现完整的请求-响应模式
  
- **路由器** (`forward_dual_enhanced.c`)：
  - 转发两个方向的数据包
  - 独立的统计信息（正向/反向）
  - 详细的转发日志

## 网络拓扑

```
源主机                路由主机              目的主机
192.168.1.2      192.168.1.1/24       192.168.2.2
   |                  eth0                  |
   |                   |                    |
   +---[192.168.1.0/24]|                    |
                       |                    |
                   eth1|----[192.168.2.0/24]+
                192.168.2.1/24
```

## 编译

```bash
# 编译发送端（需要pthread库）
gcc -o send_dual_enhanced send_dual_enhanced.c -lpthread

# 编译接收端
gcc -o recv_dual_enhanced recv_dual_enhanced.c

# 编译路由转发程序
gcc -o forward_dual_enhanced forward_dual_enhanced.c
```

## 网络配置

### 源主机（192.168.1.2）

```bash
# 配置IP地址
sudo ip addr add 192.168.1.2/24 dev eth0

# 配置默认网关
sudo ip route add default via 192.168.1.1

# 验证配置
ip addr show eth0
ip route show
```

### 路由主机（192.168.1.1/192.168.2.1）

```bash
# 配置eth0（连接源主机）
sudo ip addr add 192.168.1.1/24 dev eth0

# 配置eth1（连接目的主机）
sudo ip addr add 192.168.2.1/24 dev eth1

# 启用IP转发
sudo sysctl -w net.ipv4.ip_forward=1

# 验证配置
cat /proc/sys/net/ipv4/ip_forward  # 应该输出 1
ip addr show
```

### 目的主机（192.168.2.2）

```bash
# 配置IP地址
sudo ip addr add 192.168.2.2/24 dev eth0

# 配置默认网关
sudo ip route add default via 192.168.2.1

# 开放UDP端口（如果启用了防火墙）
sudo ufw allow 12345/udp

# 验证配置
ip addr show eth0
ip route show
```

## 运行步骤

### 1. 启动路由主机（必须最先启动）

在路由主机上：

```bash
sudo ./forward_dual_enhanced
```

预期输出：
```
╔═══════════════════════════════════════════════════════════════╗
║          双网口路由转发程序 - 增强版（支持双向转发）         ║
║                   (实验4.3 Enhanced)                          ║
╚═══════════════════════════════════════════════════════════════╝

接口配置:
  eth0: 192.168.1.1/24 (连接源主机网段)
  eth1: 192.168.2.1/24 (连接目的主机网段)

╔═══════════════════════════════════════════════════════════════╗
║                        路由表                                 ║
╠═══════════════════════════════════════════════════════════════╣
║ 目的网络          子网掩码          接口    描述             ║
╠═══════════════════════════════════════════════════════════════╣
║ 192.168.2.0       255.255.255.0     eth1    Forward: 1->2    ║
║ 192.168.1.0       255.255.255.0     eth0    Reverse: 2->1    ║
╚═══════════════════════════════════════════════════════════════╝
```

### 2. 启动接收端（目的主机）

在目的主机上：

```bash
./recv_dual_enhanced
```

预期输出：
```
╔═══════════════════════════════════════════════════════════════╗
║        UDP 双向通信程序 - 目的主机 (增强版)              ║
║              (实验4.3 Enhanced)                           ║
╚═══════════════════════════════════════════════════════════════╝

网络配置:
  本机网段:   192.168.2.0/24
  监听端口:   12345
  通过网关:   192.168.2.1
  模式:       接收并自动回复
```

### 3. 启动发送端（源主机）

在源主机上：

```bash
./send_dual_enhanced
```

预期输出：
```
╔═══════════════════════════════════════════════════════════════╗
║        UDP 双向通信程序 - 源主机 (增强版)                ║
║              (实验4.3 Enhanced)                           ║
╚═══════════════════════════════════════════════════════════════╝

网络配置:
  本机网段:   192.168.1.0/24
  目标主机:   192.168.2.2:12345 (192.168.2.0/24)
  本地端口:   54321 (用于接收响应)
  通过网关:   192.168.1.1
```

### 4. 发送测试消息

在发送端输入消息：

```
请输入消息 [1]: Hello from 192.168.1.2
```

## 验证双向通信

### 正向传输（192.168.1.2 → 192.168.2.2）

1. **发送端**显示消息已发送
2. **路由器**显示 `FORWARD (1→2)` 方向转发
3. **接收端**显示收到消息并显示"跨子网通信 (1→2)"

### 反向传输（192.168.2.2 → 192.168.1.2）

1. **接收端**自动发送回复消息
2. **路由器**显示 `REVERSE (2→1)` 方向转发
3. **发送端**的接收线程显示收到响应，并计算RTT

## 关键代码说明

### 双向路由表（forward_dual_enhanced.c）

```c
struct route_entry route_table[] = {
    // 正向路由：从1网段到2网段
    {inet_addr("192.168.2.0"), 0, inet_addr("255.255.255.0"), "eth1", "Forward: 1->2"},
    // 反向路由：从2网段到1网段
    {inet_addr("192.168.1.0"), 0, inet_addr("255.255.255.0"), "eth0", "Reverse: 2->1"}
};
```

### 双向过滤（forward_dual_enhanced.c）

```c
// 正向过滤：1.x → 2.x
int is_forward = ((ip_header->saddr & inet_addr("255.255.255.0")) == inet_addr("192.168.1.0") &&
                 (ip_header->daddr & inet_addr("255.255.255.0")) == inet_addr("192.168.2.0"));

// 反向过滤：2.x → 1.x
int is_reverse = ((ip_header->saddr & inet_addr("255.255.255.0")) == inet_addr("192.168.2.0") &&
                 (ip_header->daddr & inet_addr("255.255.255.0")) == inet_addr("192.168.1.0"));
```

### ARP缓存学习（forward_dual_enhanced.c）

```c
// 转发成功后，学习源MAC地址
add_arp_entry(ip_header->saddr, eth_header->h_source);
```

## 统计信息

程序退出时（Ctrl+C）会显示详细的统计信息：

### 路由器统计

```
╔═══════════════════════════════════════════════════════════════╗
║                      转发统计信息                             ║
╠═══════════════════════════════════════════════════════════════╣
║ 总接收包数:       10                                          ║
║ 正向转发(1→2):    5                                           ║
║ 反向转发(2→1):    5                                           ║
║ TTL过期丢弃:      0                                           ║
║ 无路由丢弃:       0                                           ║
║ 其他丢弃:         0                                           ║
╚═══════════════════════════════════════════════════════════════╝
```

### 发送端统计

```
╔═══════════════════════════════════════════════════════════════╗
║                    通信统计信息                           ║
╠═══════════════════════════════════════════════════════════════╣
║ 发送消息数:   5                                          ║
║ 接收消息数:   5                                          ║
║ 丢包率:       0.0%                                       ║
╚═══════════════════════════════════════════════════════════════╝
```

## 故障排查

### 1. 路由器无法接收数据包

- 检查是否使用 `sudo` 运行
- 验证网卡接口名称（eth0/eth1可能需要改为实际名称）
- 检查IP转发是否启用：`cat /proc/sys/net/ipv4/ip_forward`

### 2. 发送端无法收到回复

- 检查发送端是否正确绑定本地端口（54321）
- 验证路由器的反向路由表是否生效
- 使用 `tcpdump` 抓包确认数据包流向

### 3. 目的主机无法接收消息

- 检查防火墙设置：`sudo ufw status`
- 验证默认网关配置：`ip route show`
- 确认端口12345未被占用：`netstat -ulnp | grep 12345`

### 4. MAC地址问题

如果使用实际硬件，需要在 `forward_dual_enhanced.c` 中配置正确的MAC地址，或者实现完整的ARP协议。

## 与原版对比

| 特性 | Lab4-3 原版 | Lab4-3 增强版 |
|-----|------------|--------------|
| 路由方向 | 单向（1→2） | 双向（1↔2） |
| 路由表条目 | 1条 | 2条 |
| ARP支持 | 手动配置MAC | ARP缓存 + 学习 |
| 通信模式 | 单向发送 | 请求-响应 |
| 发送端功能 | 仅发送 | 发送+接收 |
| 接收端功能 | 仅接收 | 接收+回复 |
| 统计信息 | 基础 | 详细（区分方向） |
| RTT测量 | 无 | 有 |
| 多线程 | 无 | 有（发送端） |

## 实验要点

1. **路由表的双向性**：必须包含两个方向的路由条目
2. **MAC地址处理**：实现ARP缓存机制，动态学习MAC地址
3. **双向数据流**：正确处理两个方向的数据包转发
4. **应用层双向通信**：实现请求-响应模式
5. **统计和监控**：独立统计两个方向的流量

## 扩展思考

1. 如何实现完整的ARP协议？
2. 如何处理多个子网的路由？
3. 如何实现动态路由协议（如RIP、OSPF）？
4. 如何添加NAT功能？
5. 如何实现防火墙规则？

## 注意事项

1. 需要ROOT权限运行路由转发程序
2. 确保三台主机的网络配置正确
3. 按照正确的顺序启动程序（路由器→接收端→发送端）
4. 使用 `Ctrl+C` 优雅退出，查看统计信息
5. 实际硬件环境中需要配置正确的MAC地址

## 参考资料

- Linux网络编程
- TCP/IP协议详解 卷1
- AF_PACKET套接字编程
- Linux路由配置
