# 实验3:可靠数据传输协议-GBN协议的设计与实现

## 1. 实验目的

- 理解滑动窗口协议的基本原理
- 掌握GBN(Go-Back-N)的工作原理
- 掌握基于UDP设计并实现一个GBN协议的过程与技术

## 2. 实验环境

- 接入Internet的实验主机
- Windows操作系统
- 开发语言:C/C++(或Java)等

## 3. 实验内容

### 必做内容

1. **基于UDP设计一个简单的GBN协议**,实现单向可靠数据传输(服务器到客户的数据传输)
2. **模拟引入数据包的丢失**,验证所设计协议的有效性

### 选做内容(加分项目)

1. **改进所设计的GBN协议**,支持双向数据传输(可以当堂完成或课下完成)
2. **将所设计的GBN协议改进为SR协议**(Selective Repeat,选择重传协议)(可以当堂完成或课下完成)

## 4. 实验方式

每位同学独立上机编程实验,实验指导教师现场指导。

## 5. 实验要点

### 5.1 协议设计要点

1. **差错检测**
   - 基于UDP实现的GBN协议,可以不进行差错检测
   - 可以利用UDP协议差错检测
2. **数据帧格式**
   - 自行设计数据帧的格式
   - 应至少包含**序列号Seq**和**数据**两部分
3. **窗口参数**
   - 自行定义发送端序列号Seq比特数**L**
   - 自行定义发送窗口大小**W**
   - 应满足条件:**W+1 ≤ 2^L**
4. **计时器实现**
   - **非阻塞方式**:设置套接字为非阻塞方式,则服务器端在recvfrom方法上不会阻塞
   - 若正确接收到ACK消息,则计时器清零
   - 若从客户端接收数据长度为-1(表示没有接收到任何数据),则计时器+1
   - 对计时器进行判断,若其超过阈值,则判断为超时,进行超时重传
   - **阻塞方式**:可以使用select或epoll的阻塞选择函数(详情见MSDN)
5. **ACK丢失模拟**
   - 客户端对接收的数据帧进行计数
   - 对总数进行模N运算
   - 若规定求模运算结果为零则返回ACK,则每接收N个数据帧才返回1个ACK
   - 当N取值大于服务器端的超时阀值时,则会出现服务器端超时现象

### 5.2 特殊情况

- 当设置服务器端发送窗口的大小为1时,**GBN协议就是停-等协议**

## 6. 参考内容

### 6.1 GBN协议实现框架

作为只实现单向数据传输的GBN协议,实质上就是实现为一个C/S应用。

#### 服务器端

- 使用UDP协议传输数据(比如传输一个文件)
- 等待客户端的请求
- 接收并处理来自客户端的消息(如数据传输请求)
- 当客户端开始请求数据时进入"伪连接"状态
- 将数据打包成数据报发送
- 等待客户端的ACK信息,同时启动计时器
- 收到ACK时:
  - 窗口滑动
  - 正常发送下一个数据报
  - 计时器重新计时
- 计时器超时前没有收到ACK:
  - 全部重传窗口内的所有已发送的数据报

#### 客户端

- 使用UDP协议向服务器端请求数据

- 接收服务器端发送的数据报

- 返回确认信息ACK

- 注意

  :GBN为累积确认

  - 若ACK=1和3,表示数据帧2已经正确接收

- 必须能够模拟ACK丢失直至服务器端超时重传的情况

### 6.2 服务器端设计参考

#### 6.2.1 命令解析

为了测试客户端与服务器端的通信交互,方便操作,设置了命令解析过程:

| 命令       | 说明                | 服务器响应          |
| ---------- | ------------------- | ------------------- |
| `-time`    | 请求获取当前时间    | 回复当前时间        |
| `-quit`    | 客户端退出          | 回复"Good bye!"     |
| `-testgbn` | 请求开始测试GBN协议 | 开始进入GBN传输状态 |
| 其他数据   | 任意其他数据        | 直接回复原数据      |

#### 6.2.2 数据传输数据帧格式定义

在以太网中,数据帧的MTU为1500字节,所以UDP数据报的数据部分应小于1472字节(除去IP头部20字节与UDP头的8字节)。

定义UDP数据报的数据部分格式为:

```
+------+-------------+-----+
| Seq  |    Data     | EOF |
+------+-------------+-----+
1字节  ≤1024字节    1字节
```

- **Seq**:1个字节,取值为0~255(故序列号最多为256个)
- **Data**:≤1024个字节,为传输的数据
- **EOF**:最后一个字节放入0,表示结尾

#### 6.2.3 服务器端源代码框架

```c
#include "stdafx.h"
#include <stdlib.h>
#include <time.h>
#include <WinSock2.h>
#include <fstream>
#pragma comment(lib,"ws2_32.lib")

#define SERVER_PORT 12340 //端口号
#define SERVER_IP "0.0.0.0" //IP地址
const int BUFFER_LENGTH = 1026; //缓冲区大小
const int SEND_WIND_SIZE = 10; //发送窗口大小为10
const int SEQ_SIZE = 20; //序列号的个数,从0~19共计20个

BOOL ack[SEQ_SIZE]; //收到ack情况,对应0~19的ack
int curSeq; //当前数据包的seq
int curAck; //当前等待确认的ack
int totalSeq; //收到的包的总数
int totalPacket; //需要发送的包总数

// 获取当前系统时间
void getCurTime(char *ptime);

// 当前序列号curSeq是否可用
bool seqIsAvailable();

// 超时重传处理函数,滑动窗口内的数据帧都要重传
void timeoutHandler();

// 收到ack,累积确认,取数据帧的第一个字节
void ackHandler(char c);

int main(int argc, char* argv[]) {
    // 加载套接字库
    WORD wVersionRequested;
    WSADATA wsaData;
    int err;
    wVersionRequested = MAKEWORD(2, 2);
    err = WSAStartup(wVersionRequested, &wsaData);
    
    // 创建socket,设置为非阻塞模式
    SOCKET sockServer = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    int iMode = 1; //1:非阻塞,0:阻塞
    ioctlsocket(sockServer, FIONBIO, (u_long FAR*) &iMode);
    
    // 绑定端口
    SOCKADDR_IN addrServer;
    addrServer.sin_addr.S_un.S_addr = htonl(INADDR_ANY);
    addrServer.sin_family = AF_INET;
    addrServer.sin_port = htons(SERVER_PORT);
    bind(sockServer, (SOCKADDR*)&addrServer, sizeof(SOCKADDR));
    
    // 主循环:接收命令,处理GBN协议传输
    // ...具体实现见完整代码
    
    closesocket(sockServer);
    WSACleanup();
    return 0;
}
```

### 6.3 客户端设计参考

#### 6.3.1 ACK数据帧定义

由于是从服务器端到客户端的单向数据传输,因此ACK数据帧不包含任何数据,只需要将ACK发送给服务器端即可。

```
+------+-----+
| ACK  | EOF |
+------+-----+
1字节  1字节
```

- **ACK**字段:一个字节,表示序列号数值
- **EOF**:末尾放入0,表示数据结束

#### 6.3.2 命令设置

客户端的命令和服务器端的解析命令相对应:

**重点命令**:`-testgbn [X] [Y]`

- `[X]`:客户端的丢包率,模拟网络中报文丢失,取值范围[0,1]
- `[Y]`:客户端的ACK的丢失率,取值范围[0,1]
- 如果用户不输入,则默认丢失率均为0.2
- 使用随机函数完成丢包模拟

#### 6.3.3 客户端源代码框架

```c
#include "stdafx.h"
#include <stdlib.h>
#include <WinSock2.h>
#include <time.h>
#pragma comment(lib,"ws2_32.lib")

#define SERVER_PORT 12340 //接收数据的端口号
#define SERVER_IP "127.0.0.1" // 服务器的IP地址
const int BUFFER_LENGTH = 1026;
const int SEQ_SIZE = 20; //接收端序列号个数,为1~20

// 根据丢失率随机生成一个数字,判断是否丢失
// 丢失则返回TRUE,否则返回FALSE
BOOL lossInLossRatio(float lossRatio) {
    int lossBound = (int)(lossRatio * 100);
    int r = rand() % 101;
    if(r <= lossBound) {
        return TRUE;
    }
    return FALSE;
}

int main(int argc, char* argv[]) {
    // 初始化socket
    // 连接服务器
    // 接收命令
    // 处理GBN协议接收
    // ...具体实现见完整代码
    
    return 0;
}
```

## 7. 实验报告

在实验报告中要说明:

1. **协议设计**
   - 所设计GBN协议数据分组格式
   - 确认分组格式
   - 各个域的作用
2. **流程设计**
   - 协议两端程序流程图
   - 协议典型交互过程
3. **测试验证**
   - 数据分组丢失验证模拟方法
   - 实验验证结果
4. **技术实现**
   - 程序实现的主要类(或函数)及其主要作用
5. **源代码**
   - 详细注释的源程序

------

## 附录:GBN协议基本原理

### 工作原理

**Go-Back-N(回退N)**是一种滑动窗口协议:

1. **发送窗口**:大小为N,可以连续发送N个分组而无需等待确认
2. **接收窗口**:大小为1,只能按序接收分组
3. **累积确认**:接收方对按序到达的最后一个分组发送确认
4. **超时重传**:超时后重传所有已发送但未确认的分组

### 关键参数

- **序列号位数L**:序列号范围为0 ~ 2^L-1
- **窗口大小W**:满足W+1 ≤ 2^L
- **超时时间**:根据网络状况设置合适的超时阈值

### 协议特点

- ✅ 效率高于停等协议
- ✅ 实现相对简单
- ⚠️ 出错时需要重传多个分组
- ⚠️ 接收方缓存需求小(窗口大小为1)

### GBN vs 停等协议

| 特性       | 停等协议 | GBN协议  |
| ---------- | -------- | -------- |
| 发送窗口   | 1        | N(N>1)   |
| 接收窗口   | 1        | 1        |
| 信道利用率 | 低       | 较高     |
| 实现复杂度 | 简单     | 中等     |
| 重传开销   | 小       | 可能较大 |