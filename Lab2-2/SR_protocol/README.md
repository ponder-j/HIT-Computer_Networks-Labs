# SR协议 (Selective Repeat - 选择重传协议)

## 实验简介

本实验是Lab2-2的选做内容2,将GBN协议改进为SR(Selective Repeat,选择重传)协议。SR是最高效的滑动窗口协议!

## SR协议核心特性

### 与GBN的关键区别

| 特性 | GBN | SR |
|------|-----|-----|
| 接收窗口 | 1 | N (本实验为10) |
| 乱序处理 | 丢弃 | **缓存** |
| 重传策略 | 回退N(全部重传) | **选择重传**(只传丢失的) |
| ACK方式 | 累积确认 | **独立确认** |
| 缓存需求 | 低 | 高 |
| 效率 | 中 | **高** |

### SR协议的优势

1. **接收窗口 > 1**
   ```
   GBN: [base]         -> 窗口大小1,只能按序接收
   SR:  [base, ..., base+N-1] -> 窗口大小N,可缓存乱序包
   ```

2. **选择重传**
   ```
   丢失Seq=2时:
   GBN: 重传 2,3,4,5,... (所有未确认的)
   SR:  只重传 2 (仅丢失的包)
   ```

3. **独立ACK**
   ```
   GBN: ACK=5 表示 0-5都收到
   SR:  ACK=5 只表示 5收到,其他包各自ACK
   ```

## 协议设计

### 发送端状态

```cpp
// 发送窗口
int sendBase;              // 窗口基序号
int nextSeqNum;            // 下一个可用序列号
BOOL sendAck[SEQ_SIZE];    // 每个包的ACK状态
vector<DataFrame> sendBuffer; // 发送缓冲区

// 窗口: [sendBase, sendBase+SEND_WIND_SIZE-1]
```

### 接收端状态

```cpp
// 接收窗口(SR关键!)
int recvBase;              // 窗口基序号
BOOL recvAck[SEQ_SIZE];    // 已接收标记
map<int, DataFrame> recvBuffer; // 乱序包缓存

// 窗口: [recvBase, recvBase+RECV_WIND_SIZE-1]
```

### 数据帧格式

```cpp
struct DataFrame {
    unsigned char seq;     // 序列号(0-19)
    char data[1024];       // 数据
    unsigned char flag;    // 0=数据, 1=结束, 2=ACK
};
```

## 工作流程

### 发送端

```
1. 在窗口内发送数据包
2. 为每个包启动独立计时器(简化:统一计时)
3. 收到ACK时:
   - 标记该包已确认
   - 如果是sendBase,滑动窗口
4. 超时时:
   - 选择重传未确认的包(不是全部!)
```

### 接收端

```
1. 收到数据包:
   - 检查是否在接收窗口内
   - 在窗口内: 缓存并发送ACK
   - 不在窗口内: 丢弃

2. 如果收到recvBase:
   - 交付连续的数据
   - 滑动接收窗口

3. 如果收到乱序包:
   - 缓存起来
   - 立即发送ACK
   - 等待中间的包到达
```

## 编译说明

```bash
cd Lab2-2/SR_protocol

# 编译服务器
g++ server.cpp -o server.exe -lws2_32

# 编译客户端
g++ client.cpp -o client.exe -lws2_32
```

## 运行说明

### 1. 启动服务器

```bash
./server.exe
```

输出:
```
========================================
SR协议服务器(Selective Repeat)
监听端口: 12340
发送窗口: 10
接收窗口: 10 (SR特性!)
序列号: 0-19
========================================
```

### 2. 启动客户端

```bash
./client.exe
```

### 3. 测试命令

```
-testsr [数据包丢失率] [ACK丢失率]
```

示例:
```
请输入命令: -testsr 0.3 0.2
```

## 测试示例

### 测试1: 无丢包,观察窗口

```
请输入命令: -testsr 0 0
```

**服务器输出**:
```
[开始] SR协议测试
========================================
[发送窗口] base=0, next=0
  [|××××××××××|         ]

[发送] Seq=0, 数据="SR-1:选择重传协议"
[发送] Seq=1, 数据="SR-2:接收窗口>1"
...
[发送] Seq=9, 数据="SR-10:计算机网络"

[ACK处理] 收到ACK=0
[确认] Seq=0 已确认
[窗口滑动] 新base=1
[发送窗口] base=1, next=10
  [ |×××××××××|        ]

...
```

**客户端输出**:
```
  窗口[|··········|         ] base=0

[接收] Seq=0, 数据="SR-1:选择重传协议"
[按序] Seq=0
[发送ACK] ACK=0
[交付] 开始交付连续数据:
  -> Seq=0, 数据="SR-1:选择重传协议"
  新recvBase=1
  窗口[ |·········|        ] base=1

[接收] Seq=1, 数据="SR-2:接收窗口>1"
[按序] Seq=1
[发送ACK] ACK=1
...
```

### 测试2: 模拟乱序,观察缓存

```
请输入命令: -testsr 0.3 0.2
```

**关键现象**:

**服务器**:
```
[发送] Seq=0, 数据="SR-1:..."
[发送] Seq=1, 数据="SR-2:..."
[发送] Seq=2, 数据="SR-3:..."  <- 假设ACK丢失
[发送] Seq=3, 数据="SR-4:..."
...

[ACK处理] 收到ACK=0
[ACK处理] 收到ACK=1
[ACK处理] 收到ACK=3  <- 收到3但2未确认
[确认] Seq=3 已确认
[发送窗口] base=0, next=10
  [|√√×√...     |         ]
            ↑
         Seq=2未确认

[超时] 选择重传未确认的数据包...
[重传] Seq=2, 数据="SR-3:..."  <- 只重传2!
[重传] 共重传 1 个数据包

[ACK处理] 收到ACK=2
[确认] Seq=2 已确认
[窗口滑动] 新base=4  <- 滑动到4
```

**客户端**:
```
[接收] Seq=0, 数据="SR-1:..."
[按序] Seq=0
[发送ACK] ACK=0

[接收] Seq=1, 数据="SR-2:..."
[按序] Seq=1
[发送ACK] ACK=1

[接收] Seq=2, 数据="SR-3:..." -> [丢弃]模拟丢包!
  ↑ 数据包2丢失

[接收] Seq=3, 数据="SR-4:..."
[乱序] Seq=3 不是期望的 2, 缓存!  <- SR特性:缓存!
[发送ACK] ACK=3
  窗口[  |×·×......|       ] base=2
           ↑ ↑
         收到3,缺2

[接收] Seq=4, 数据="SR-5:..."
[乱序] Seq=4 不是期望的 2, 缓存!
[发送ACK] ACK=4
  窗口[  |×·××.....  |       ] base=2
           ↑ ↑ ↑
         收到3,4,5,缺2

... (等待重传)

[接收] Seq=2, 数据="SR-3:..."  <- 重传到达!
[按序] Seq=2
[发送ACK] ACK=2
[交付] 开始交付连续数据:  <- SR特性:交付缓存的数据!
  -> Seq=2, 数据="SR-3:..."
  -> Seq=3, 数据="SR-4:..."
  -> Seq=4, 数据="SR-5:..."
  -> Seq=5, 数据="SR-6:..."
  新recvBase=6
  窗口[      |····· |       ] base=6
```

**重点**:
- GBN会丢弃3,4,5,全部重传
- SR缓存3,4,5,只重传2,效率高!

### 测试3: 高丢包率压力测试

```
请输入命令: -testsr 0.4 0.4
```

**预期结果**:
- 大量乱序包被缓存
- 多次选择重传
- 最终所有数据正确交付
- 比GBN重传次数少

## 运行示例对比

### GBN协议 vs SR协议

**场景**: Seq=2丢失

**GBN**:
```
发送: 0 1 2 3 4 5
接收: 0 1 X 3 4 5
处理: 0✓ 1✓ X丢弃 丢弃 丢弃 丢弃
重传: 2 3 4 5 (回退,全部重传)
结果: 重传4个包
```

**SR**:
```
发送: 0 1 2 3 4 5
接收: 0 1 X 3 4 5
处理: 0✓ 1✓ X缓存 缓存 缓存 缓存
重传: 2 (选择,只传丢失的)
交付: 2 3 4 5 (从缓存交付)
结果: 重传1个包
```

**效率提升**: SR比GBN少重传75%!

## 关键技术实现

### 1. 接收窗口管理

```cpp
bool inRecvWindow(int seq) {
    // 判断seq是否在[recvBase, recvBase+RECV_WIND_SIZE-1]内
    if (recvBase <= recvBase + RECV_WIND_SIZE - 1) {
        return seq >= recvBase && seq < recvBase + RECV_WIND_SIZE;
    } else {
        // 处理序列号回绕
        return seq >= recvBase || seq < (recvBase + RECV_WIND_SIZE) % SEQ_SIZE;
    }
}
```

### 2. 乱序包缓存

```cpp
if (inRecvWindow(seq)) {
    if (!recvAck[seq]) {
        // 新包,缓存
        recvBuffer[seq] = frame;  // map缓存
        recvAck[seq] = TRUE;

        // 立即发送独立ACK
        sendAck(seq);
    }
}
```

### 3. 连续数据交付

```cpp
if (seq == recvBase) {
    // 收到recvBase,交付连续数据
    while (recvAck[recvBase]) {
        // 交付recvBase
        deliverData(recvBuffer[recvBase]);
        recvBuffer.erase(recvBase);

        // 滑动窗口
        recvAck[recvBase] = FALSE;
        recvBase = (recvBase + 1) % SEQ_SIZE;
    }
}
```

### 4. 选择重传

```cpp
void selectiveRetransmit() {
    // 只重传sendBase到nextSeqNum之间未确认的包
    for (int i = sendBase; i != nextSeqNum; i = (i + 1) % SEQ_SIZE) {
        if (!sendAck[i]) {  // 未确认
            retransmit(sendBuffer[i]);  // 重传
        }
    }
}
```

### 5. 独立ACK处理

```cpp
void ackHandler(unsigned char ackSeq) {
    sendAck[ackSeq] = TRUE;  // 标记该包已确认

    // 如果是sendBase,滑动窗口
    while (sendAck[sendBase]) {
        sendAck[sendBase] = FALSE;
        sendBase = (sendBase + 1) % SEQ_SIZE;
    }
}
```

## 协议对比总结

| 协议 | 停等 | GBN | SR |
|------|------|-----|-----|
| 发送窗口 | 1 | N | N |
| 接收窗口 | 1 | 1 | **N** |
| 乱序处理 | 无 | 丢弃 | **缓存** |
| 重传 | 单个 | 回退N | **选择** |
| ACK | 单独 | 累积 | **独立** |
| 效率 | 低 | 中 | **高** |
| 缓存 | 低 | 低 | **高** |
| 复杂度 | 低 | 中 | **高** |
| 适用 | 简单 | 低丢包 | **高速/高丢包** |

## 性能分析

### 信道利用率

**理想情况**(无丢包):
- **停等**: U = 1 / (1 + 2a)
- **GBN**: U ≈ N / (1 + 2a)  (N≤1+2a时)
- **SR**: U ≈ N / (1 + 2a)  (N≤1+2a时)

**有丢包**(丢包率p):
- **GBN**: 重传多个包,效率降低显著
- **SR**: 只重传丢失包,效率降低较小

### 重传开销对比

丢失1个包时:
- **停等**: 重传1个
- **GBN**: 重传该包及之后所有包(可能10+个)
- **SR**: 只重传该包(1个)

**示例**: 窗口10,Seq=5丢失
- GBN: 重传5,6,7,8,9(5个)
- SR: 重传5(1个)
- **SR效率提升**: 80%!

## 验证要点

- ✓ 接收窗口大小 > 1
- ✓ 乱序包被缓存而非丢弃
- ✓ 独立ACK机制工作正常
- ✓ 选择重传只传丢失的包
- ✓ 连续数据正确交付
- ✓ 窗口滑动正确
- ✓ 高丢包率下仍高效
- ✓ 最终数据完整

## 常见问题

### Q1: SR为什么效率最高?

A:
- 接收窗口>1: 不丢弃乱序包
- 选择重传: 只传丢失的,不重复传输
- 独立ACK: 及时反馈每个包的状态

### Q2: SR的缺点是什么?

A:
- 实现复杂度高
- 需要更多缓存(接收端和发送端)
- 需要维护更多状态

### Q3: 为什么需要接收窗口?

A:
- 防止序列号混淆
- 限制缓存大小
- 满足条件: 接收窗口 ≤ SEQ_SIZE / 2

### Q4: SR适用于什么场景?

A:
- 高速网络(大带宽延迟积)
- 高丢包率网络
- 需要高效率的应用
- 例如: 卫星通信,无线网络

## TCP与SR的关系

TCP的可靠传输机制借鉴了SR思想:
- 缓存乱序数据
- 快速重传(类似选择重传)
- 选择确认SACK选项(Selective ACK)

## 改进方向

1. **定时器优化**
   - 为每个包维护独立计时器
   - 动态调整超时时间

2. **窗口自适应**
   - 根据网络状况动态调整窗口大小
   - 拥塞控制

3. **NAK机制**
   - 接收方主动请求重传
   - 加快错误恢复

4. **piggybacking**
   - 在数据帧中捎带ACK
   - 减少ACK包数量

## 总结

SR协议是**最高效的滑动窗口协议**,通过:
- ✅ 接收窗口>1缓存乱序包
- ✅ 选择重传减少重复传输
- ✅ 独立ACK及时反馈

在高丢包率和大带宽延迟积网络中,SR比GBN效率**显著提高**!

这是网络协议学习的重要里程碑,理解SR协议对掌握TCP等实际协议非常有帮助!
