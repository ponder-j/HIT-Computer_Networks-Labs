# Lab2-2: GBN协议 (Go-Back-N Protocol)

## 实验简介

本实验基于UDP协议实现了GBN(Go-Back-N,回退N)协议,实现从服务器到客户端的单向可靠数据传输。GBN是一种滑动窗口协议,效率高于停等协议。

## 协议设计

### 数据帧格式

```
+------+------------------+------+
| Seq  |      Data        | Flag |
+------+------------------+------+
1字节    ≤1024字节         1字节
```

- **Seq**: 序列号,范围0-19 (可配置为0到SEQ_SIZE-1)
- **Data**: 传输的数据内容
- **Flag**: 标志位,0表示普通数据帧,1表示最后一帧

### ACK帧格式

```
+------+------+
| ACK  | Flag |
+------+------+
1字节   1字节
```

- **ACK**: 确认序列号,采用累积确认机制
- **Flag**: 标志位

## 协议参数

- **发送窗口大小(SEND_WIND_SIZE)**: 10
- **序列号空间(SEQ_SIZE)**: 20 (满足条件: W+1 ≤ 2^L)
- **超时阈值(TIMEOUT_THRESHOLD)**: 50个时间单位

## 工作原理

### 发送方(服务器)

1. **滑动窗口发送**:
   - 维护大小为10的发送窗口
   - 可连续发送窗口内的多个数据包
   - 不需要等待每个包的ACK

2. **累积确认处理**:
   - 收到ACK=n,表示n及之前的包都已正确接收
   - 窗口向前滑动到下一个未确认的包

3. **超时重传**:
   - 使用非阻塞socket和计时器
   - 超时后重传窗口内所有未确认的包
   - Go-Back-N:回退到出错位置重传

### 接收方(客户端)

1. **按序接收**:
   - 只接受期望序列号的数据包
   - 接收窗口大小为1

2. **累积确认**:
   - 发送对正确接收包的ACK
   - 收到乱序包时,重发上一个ACK

3. **丢包模拟**:
   - 模拟数据包丢失
   - 模拟ACK丢失
   - 可配置丢失率

## 文件说明

- `server.cpp`: 服务器端程序(发送方)
- `client.cpp`: 客户端程序(接收方)
- `实验要求.md`: 实验要求文档

## 编译说明

### 使用g++编译 (MinGW)

```bash
# 编译服务器
g++ server.cpp -o server.exe -lws2_32

# 编译客户端
g++ client.cpp -o client.exe -lws2_32
```

### 使用MSVC编译

```bash
# 编译服务器
cl server.cpp /Fe:server.exe ws2_32.lib

# 编译客户端
cl client.cpp /Fe:client.exe ws2_32.lib
```

## 运行说明

### 1. 启动服务器

```bash
./server.exe
```

服务器将在端口12340上监听,显示:
- 监听端口
- 窗口大小
- 序列号范围

### 2. 启动客户端

在另一个终端窗口运行:

```bash
./client.exe
```

### 3. 可用命令

客户端支持以下命令:

- `-time`: 获取服务器时间
- `-testgbn [X] [Y]`: 测试GBN协议
  - `X`: 数据包丢失率 (0.0-1.0,默认0.2)
  - `Y`: ACK丢失率 (0.0-1.0,默认0.2)
  - 示例: `-testgbn 0.3 0.2` (30%数据包丢失,20% ACK丢失)
- `-quit`: 退出客户端
- 其他文本: 回显测试

## 测试示例

### 1. 无丢包测试

```
请输入命令: -testgbn 0 0
```

观察结果:
- 服务器连续发送多个包(窗口大小10)
- 客户端按序接收并发送ACK
- 窗口平滑滑动
- 传输效率高

### 2. 数据包丢失测试

```
请输入命令: -testgbn 0.3 0
```

观察结果:
- 客户端丢弃30%的数据包
- 服务器超时后回退重传
- 所有数据最终都能正确传输

### 3. ACK丢失测试

```
请输入命令: -testgbn 0 0.3
```

观察结果:
- 30%的ACK丢失
- 服务器未收到ACK,触发超时
- 重传窗口内所有数据包
- 累积确认机制帮助恢复

### 4. 综合测试

```
请输入命令: -testgbn 0.2 0.2
```

观察结果:
- 同时模拟数据包和ACK丢失
- 测试协议在恶劣网络环境下的表现
- 验证可靠传输机制

## 运行示例输出

### 服务器端

```
======================================
GBN协议服务器已启动
监听端口: 12340
窗口大小: 10
序列号范围: 0-19
======================================

[接收] 来自 127.0.0.1:xxxxx - -testgbn

[开始] GBN协议测试
======================================
准备发送 15 个数据包
[窗口状态] curAck=0, curSeq=0, 窗口大小=10
  [|×××××××××× |         ]

[发送] Seq=0, 数据="数据包1:GBN协议测试开始"
[发送] Seq=1, 数据="数据包2:Go-Back-N测试"
...
[ACK处理] 收到ACK=0
[窗口滑动] 新的curAck=1
...
[完成] GBN协议测试完成!
总共发送: 15 个数据包
======================================
```

### 客户端

```
[开始] GBN协议测试
数据包丢失率: 20%
ACK丢失率: 20%
======================================

[接收] Seq=0, 数据="数据包1:GBN协议测试开始"
[接受] 序列号正确,发送ACK=0
[发送] ACK=0

[接收] Seq=1, 数据="数据包2:Go-Back-N测试"
[接受] 序列号正确,发送ACK=1
[丢失] 模拟ACK丢失!

[接收] Seq=2, 数据="数据包3:滑动窗口协议" -> [丢弃] 模拟数据包丢失!
...

[完成] 收到结束标志!
======================================
接收统计:
  成功接收: 15 个数据包
  丢弃数据包: 5 个
  丢失ACK: 3 个
======================================
```

## 关键技术点

### 1. 滑动窗口机制

```cpp
// 判断当前序列号是否在窗口内
bool seqIsAvailable() {
    int step = (curSeq + SEQ_SIZE - curAck) % SEQ_SIZE;
    return step < SEND_WIND_SIZE;
}
```

- 发送方维护 [curAck, curAck+SEND_WIND_SIZE) 窗口
- 可以连续发送窗口内的包

### 2. 累积确认

- ACK=n 表示序列号≤n的所有包都已正确接收
- 减少ACK数量,提高效率
- 帮助快速恢复丢失的ACK

### 3. 超时重传

```cpp
void timeoutHandler() {
    // 重传窗口内所有未确认的包
    for (int i = curAck; i != curSeq; i = (i + 1) % SEQ_SIZE) {
        sendPacket(packets[i]);
    }
}
```

- Go-Back-N:回退到curAck,重传所有未确认的包
- 实现简单,但可能重传已正确接收的包

### 4. 非阻塞socket

```cpp
u_long iMode = 1;  // 非阻塞模式
ioctlsocket(sockServer, FIONBIO, &iMode);
```

- 使用非阻塞socket配合计时器
- 不阻塞在recvfrom(),可以检测超时

### 5. 序列号回绕

- 序列号有限(0-19),需要处理回绕
- 使用模运算: `(seq + 1) % SEQ_SIZE`

## GBN vs 停等协议对比

| 特性         | 停等协议      | GBN协议           |
| ------------ | ------------- | ----------------- |
| 发送窗口     | 1             | 10                |
| 接收窗口     | 1             | 1                 |
| 信道利用率   | 低            | 高                |
| 实现复杂度   | 简单          | 中等              |
| 重传开销     | 小(一次一个)  | 可能较大(回退N)   |
| 确认机制     | 单独确认      | 累积确认          |
| 适用场景     | 高延迟网络    | 低丢包率网络      |

## 性能分析

### 信道利用率

- **停等协议**: U = 1 / (1 + 2a),其中 a = 传播时延/发送时延
- **GBN协议**:
  - 无差错: U ≈ min(W, 1 + 2a) / (1 + 2a)
  - 有差错: 受丢包率影响,但优于停等

### 窗口大小选择

- 本实验: W = 10, SEQ_SIZE = 20
- 满足条件: W + 1 ≤ SEQ_SIZE (避免序列号混淆)
- 窗口越大,信道利用率越高(但需要更多缓存)

## 改进方向

1. **SR协议(Selective Repeat,选择重传)**:
   - 接收窗口 > 1
   - 只重传出错的包
   - 效率更高,但实现更复杂

2. **动态超时**:
   - 根据RTT动态调整超时时间
   - 类似TCP的RTO计算

3. **快速重传**:
   - 收到3个重复ACK立即重传
   - 不等待超时

4. **流量控制**:
   - 接收方通告窗口大小
   - 防止接收方缓存溢出

## 实验验证要点

- ✓ 滑动窗口机制正确实现
- ✓ 累积确认工作正常
- ✓ 超时重传触发正确
- ✓ Go-Back-N重传所有未确认包
- ✓ 数据包丢失模拟有效
- ✓ ACK丢失模拟有效
- ✓ 序列号回绕处理正确
- ✓ 最终数据完整传输

## 注意事项

1. 确保防火墙允许UDP 12340端口
2. 先启动服务器再启动客户端
3. 窗口大小和序列号空间需满足: W+1 ≤ SEQ_SIZE
4. 丢包率过高(>0.5)可能导致传输效率很低
5. 超时阈值需要根据网络延迟调整

## 常见问题

### Q1: 为什么需要 W+1 ≤ SEQ_SIZE?

A: 防止序列号混淆。如果W=SEQ_SIZE,接收方无法区分新包和重传包。

### Q2: GBN为什么要回退重传所有包?

A: 因为接收窗口=1,只能按序接收。丢失一个包后,后续包都会被拒绝。

### Q3: 累积确认有什么好处?

A: 减少ACK数量,某个ACK丢失不影响(后续ACK会确认),提高效率。

### Q4: 如何提高GBN效率?

A:
- 增大窗口(在条件允许下)
- 降低丢包率
- 优化超时时间
- 升级到SR协议
