# 实验1:HTTP 代理服务器的设计与实现
## 1. 实验目的
1. 熟悉并掌握Socket网络编程的过程与技术；
2. 深入理解HTTP协议，掌握HTTP代理服务器的基本工作原理；
3. 掌握HTTP代理服务器设计与编程实现的基本技能。

## 2. 实验环境
- 接入Internet的实验主机；
- Windows操作系统；
- 开发语言：C/C++(或Java)等。

## 3. 实验内容
### 3.1 基础功能（必做）
设计并实现一个基本HTTP代理服务器。要求在指定端口（例如8080）接收来自客户的HTTP请求，根据请求中的URL地址访问该地址所指向的HTTP服务器（原服务器），接收原服务器的响应报文，并将响应报文转发给对应的客户以支持浏览。

### 3.2 选做功能（加分项目，可当堂或课下完成）
#### 3.2.1 支持Cache功能
设计并实现支持Cache功能的HTTP代理服务器。要求能缓存原服务器响应的对象，并通过修改请求报文（添加`if-modified-since`头行），向原服务器确认缓存对象是否为最新版本。

#### 3.2.2 功能扩展
扩展HTTP代理服务器，支持以下任一或多个功能：
- 网站过滤：允许/不允许访问某些特定网站；
- 用户过滤：支持/不支持某些特定用户访问外部网站；
- 网站引导：将用户对某个网站的访问引导至一个模拟网站（钓鱼）。

## 4. 实验步骤
### 4.1 浏览器代理设置
为使浏览器通过代理服务器访问网址，需进行相关配置（以IE浏览器为例）：
1. 打开浏览器，依次进入“工具”→“浏览器选项”→“连接”→“局域网设置”；
2. 在“代理服务器”模块，勾选“为LAN使用代理服务器”（该设置不用于拨号或VPN连接）；
3. 填写代理服务器地址（如`127.0.0.1`）和端口（需与代理服务器监听端口一致，示例为10240）；
4. 可根据需求选择是否勾选“对于本地地址不使用代理服务器”，完成后点击“确定”。

### 4.2 多线程使用
使用`_beginthreadex`函数创建子线程，使用`_endthreadex`函数结束线程，具体实现细节可参考CSDN相关教程。

### 4.3 开发与测试验证
1. 编写HTTP代理服务器代码，完成后部署并运行；
2. 测试验证：可自行测试功能是否正常，也可与其他同学交叉验证，确保代理请求转发、响应处理等核心流程无误。

## 5. 实验方式
每位同学独立上机编程实验，实验指导教师现场提供技术指导。

## 6. 参考内容
### 6.1 代理服务器基本概念
代理服务器（俗称“翻墙软件”）允许一个网络终端（通常为客户端）通过该服务与另一个网络终端（通常为服务器）进行非直接连接。普通Web应用通信方式与采用代理服务器的通信方式对比如下图（图1-2）所示：
| 普通Web通信                                              | 代理服务器通信                                               |
| -------------------------------------------------------- | ------------------------------------------------------------ |
| client1 → server<br>client2 → server<br>clientN → server | client1 → proxy → server<br>client2 → proxy → server<br>clientN → proxy → server |

### 6.2 代理服务器工作流程
1. 监听与请求接收：代理服务器在指定端口（如8080）监听浏览器的访问请求（需提前在客户端浏览器配置对应代理端口）；
2. 缓存检索与请求修改：接收到浏览器请求后，代理服务器先在缓存中检索URL对应的对象（网页、图像等）。若存在缓存，提取对象最新修改时间，并在客户请求报文首部插入`If-Modified-Since: 对象文件的最新被修改时间`，再转发给原Web服务器；若不存在缓存，直接转发请求报文；
3. 响应处理与缓存更新：接收原服务器返回的响应，一方面转发给客户端，另一方面将响应对象缓存到代理服务器中；
4. 缓存管理：代理服务器会根据缓存的时间、大小和提取记录等规则，定期清理缓存以释放空间。

### 6.3 代理服务器实现步骤
#### 6.3.1 单用户代理服务器（非并发）
1. 创建TCP主套接字：代理服务器创建用于HTTP代理服务的TCP主套接字；
2. 监听连接：通过主套接字监听客户端的连接请求；
3. 处理连接：客户端连接后，读取其HTTP请求报文，解析URL以获取原服务器IP地址；
4. 转发请求与接收响应：创建访问原服务器的TCP套接字，转发HTTP请求报文，接收原服务器响应报文；
5. 响应转发与资源释放：将响应报文转发给客户端，关闭套接字，等待下一次连接。

#### 6.3.2 多用户代理服务器（多线程并发）
1. 创建TCP主套接字并监听：与单用户版本一致，创建主套接字并监听客户端连接请求；
2. 多线程处理：客户端连接后，创建子线程，由子线程执行“读取请求→解析地址→转发请求→接收响应→转发响应”的一对一代理过程；
3. 主线程循环：子线程处理服务期间，主线程继续监听并接受下一个客户的代理请求，实现多用户并发访问。

### 6.4 参考代码
```c
#include "stdafx.h" 
#include <stdio.h> 
#include <Windows.h> 
#include <process.h> 
#include <string.h> 
#pragma comment(lib,"Ws2_32.lib")

#define MAXSIZE 65507 // 发送数据报文的最大长度
#define HTTP_PORT 80  // HTTP服务器端口 

// HTTP重要头部数据结构
struct HttpHeader{ 
    char method[4];        // POST/GET（暂不考虑CONNECT）
    char url[1024];        // 请求的URL 
    char host[1024];       // 目标主机 
    char cookie[1024 * 10];// Cookie 
    HttpHeader(){ 
        ZeroMemory(this, sizeof(HttpHeader)); 
    } 
}; 

// 函数声明
BOOL InitSocket(); 
void ParseHttpHead(char *buffer, HttpHeader *httpHeader); 
BOOL ConnectToServer(SOCKET *serverSocket, char *host); 
unsigned int __stdcall ProxyThread(LPVOID lpParameter); 

// 代理相关参数
SOCKET ProxyServer;                  // 代理服务器套接字
sockaddr_in ProxyServerAddr;         // 代理服务器地址结构
const int ProxyPort = 10240;         // 代理服务器监听端口

// 代理参数结构（传递给子线程）
struct ProxyParam{ 
    SOCKET clientSocket;  // 客户端套接字
    SOCKET serverSocket;  // 目标服务器套接字
}; 

int _tmain(int argc, _TCHAR* argv[]) 
{
    printf("代理服务器正在启动\n"); 
    printf("初始化...\n"); 
    if (!InitSocket()){ 
        printf("socket初始化失败\n"); 
        return -1; 
    } 
    printf("代理服务器正在运行,监听端口 %d\n", ProxyPort); 

    SOCKET acceptSocket = INVALID_SOCKET; 
    ProxyParam *lpProxyParam; 
    HANDLE hThread; 
    DWORD dwThreadID; 

    // 代理服务器循环监听
    while (true){ 
        acceptSocket = accept(ProxyServer, NULL, NULL); 
        lpProxyParam = new ProxyParam; 
        if (lpProxyParam == NULL){ 
            continue; 
        } 
        lpProxyParam->clientSocket = acceptSocket; 

        // 创建子线程处理代理请求
        hThread = (HANDLE)_beginthreadex(NULL, 0, &ProxyThread, (LPVOID)lpProxyParam, 0, 0); 
        CloseHandle(hThread); 
        Sleep(200); 
    } 

    // 资源释放
    closesocket(ProxyServer); 
    WSACleanup(); 
    return 0; 
} 

// 函数：初始化套接字
BOOL InitSocket(){ 
    WORD wVersionRequested; 
    WSADATA wsaData; 
    int err; 

    // 请求Socket版本2.2
    wVersionRequested = MAKEWORD(2, 2); 
    // 加载Socket库
    err = WSAStartup(wVersionRequested, &wsaData); 
    if (err != 0){ 
        printf("加载winsock失败,错误代码为: %d\n", WSAGetLastError()); 
        return FALSE; 
    } 

    // 验证版本
    if (LOBYTE(wsaData.wVersion) != 2 || HIBYTE(wsaData.wVersion) != 2){ 
        printf("不能找到正确的winsock版本\n"); 
        WSACleanup(); 
        return FALSE; 
    } 

    // 创建TCP套接字
    ProxyServer = socket(AF_INET, SOCK_STREAM, 0); 
    if (INVALID_SOCKET == ProxyServer){ 
        printf("创建套接字失败,错误代码为:%d\n", WSAGetLastError()); 
        return FALSE; 
    } 

    // 配置服务器地址
    ProxyServerAddr.sin_family = AF_INET; 
    ProxyServerAddr.sin_port = htons(ProxyPort); 
    ProxyServerAddr.sin_addr.S_un.S_addr = INADDR_ANY; 

    // 绑定套接字
    if (bind(ProxyServer, (SOCKADDR*)&ProxyServerAddr, sizeof(SOCKADDR)) == SOCKET_ERROR){ 
        printf("绑定套接字失败\n"); 
        return FALSE; 
    } 

    // 开始监听
    if (listen(ProxyServer, SOMAXCONN) == SOCKET_ERROR){ 
        printf("监听端口%d失败", ProxyPort); 
        return FALSE; 
    } 

    return TRUE; 
} 

// 函数：子线程执行的代理逻辑
unsigned int __stdcall ProxyThread(LPVOID lpParameter){ 
    char Buffer[MAXSIZE]; 
    char *CacheBuffer; 
    ZeroMemory(Buffer, MAXSIZE); 

    SOCKADDR_IN clientAddr; 
    int length = sizeof(SOCKADDR_IN); 
    int recvSize; 
    int ret; 

    // 接收客户端请求
    recvSize = recv(((ProxyParam*)lpParameter)->clientSocket, Buffer, MAXSIZE, 0); 
    if (recvSize <= 0){ 
        goto error; 
    } 

    // 解析HTTP头部
    HttpHeader* httpHeader = new HttpHeader(); 
    CacheBuffer = new char[recvSize + 1]; 
    ZeroMemory(CacheBuffer, recvSize + 1); 
    memcpy(CacheBuffer, Buffer, recvSize); 
    ParseHttpHead(CacheBuffer, httpHeader); 
    delete CacheBuffer; 

    // 连接目标服务器
    if (!ConnectToServer(&((ProxyParam*)lpParameter)->serverSocket, httpHeader->host)) { 
        goto error; 
    } 
    printf("代理连接主机 %s 成功\n", httpHeader->host); 

    // 转发客户端请求到目标服务器
    ret = send(((ProxyParam*)lpParameter)->serverSocket, Buffer, strlen(Buffer) + 1, 0); 

    // 接收目标服务器响应
    recvSize = recv(((ProxyParam*)lpParameter)->serverSocket, Buffer, MAXSIZE, 0); 
    if (recvSize <= 0){ 
        goto error; 
    } 

    // 转发响应到客户端
    ret = send(((ProxyParam*)lpParameter)->clientSocket, Buffer, sizeof(Buffer), 0); 

// 错误处理与资源释放
error: 
    printf("关闭套接字\n"); 
    Sleep(200); 
    closesocket(((ProxyParam*)lpParameter)->clientSocket); 
    closesocket(((ProxyParam*)lpParameter)->serverSocket); 
    delete lpParameter; 
    _endthreadex(0); 
    return 0; 
} 

// 函数：解析HTTP头部
void ParseHttpHead(char *buffer, HttpHeader *httpHeader){ 
    char *p; 
    char *ptr; 
    const char *delim = "\r\n"; 

    // 提取请求行（第一行）
    p = strtok_s(buffer, delim, &ptr); 
    printf("%s\n", p); 

    // 判断请求方法（GET/POST）并提取URL
    if (p[0] == 'G'){// GET方式 
        memcpy(httpHeader->method, "GET", 3); 
        memcpy(httpHeader->url, &p[4], strlen(p) - 13); 
    } 
    else if (p[0] == 'P'){// POST方式 
        memcpy(httpHeader->method, "POST", 4); 
        memcpy(httpHeader->url, &p[5], strlen(p) - 14); 
    } 
    printf("%s\n", httpHeader->url); 

    // 提取后续头部字段（Host/Cookie）
    p = strtok_s(NULL, delim, &ptr); 
    while (p){ 
        switch (p[0]){ 
            case 'H':// Host字段 
                memcpy(httpHeader->host, &p[6], strlen(p) - 6); 
                break; 
            case 'C':// Cookie字段 
                if (strlen(p) > 8){ 
                    char header[8]; 
                    ZeroMemory(header, sizeof(header)); 
                    memcpy(header, p, 6); 
                    if (!strcmp(header, "Cookie")){ 
                        memcpy(httpHeader->cookie, &p[8], strlen(p) - 8); 
                    } 
                } 
                break; 
            default: 
                break; 
        } 
        p = strtok_s(NULL, delim, &ptr); 
    } 
} 

// 函数：连接目标服务器
BOOL ConnectToServer(SOCKET *serverSocket, char *host){ 
    sockaddr_in serverAddr; 
    serverAddr.sin_family = AF_INET; 
    serverAddr.sin_port = htons(HTTP_PORT); 

    // 通过主机名获取IP地址
    HOSTENT *hostent = gethostbyname(host); 
    if (!hostent){ 
        return FALSE; 
    } 
    in_addr Inaddr = *( (in_addr*) *hostent->h_addr_list); 
    serverAddr.sin_addr.s_addr = inet_addr(inet_ntoa(Inaddr)); 

    // 创建连接目标服务器的套接字
    *serverSocket = socket(AF_INET, SOCK_STREAM, 0); 
    if (*serverSocket == INVALID_SOCKET){ 
        return FALSE; 
    } 

    // 连接目标服务器
    if (connect(*serverSocket, (SOCKADDR *)&serverAddr, sizeof(serverAddr)) == SOCKET_ERROR){ 
        closesocket(*serverSocket); 
        return FALSE; 
    } 

    return TRUE;
}