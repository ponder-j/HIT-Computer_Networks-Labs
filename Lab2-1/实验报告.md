# Lab2-1 停等协议实验报告

## 一、实验概述

本实验实现了基于UDP的停等协议（Stop-and-Wait Protocol），通过客户端-服务器模型验证了可靠数据传输机制。实验模拟了数据包丢失和ACK丢失的场景，验证了协议的超时重传机制。

## 二、协议设计

### 2.1 数据分组格式

#### 数据帧结构（DataFrame）

```cpp
struct DataFrame {
    unsigned char seq;      // 序列号 (0或1)
    char data[BUFFER_SIZE]; // 数据（1024字节）
    unsigned char flag;     // 标志位: 0=数据帧, 1=结束帧
};
```

**各域作用说明：**

| 字段名 | 类型 | 大小 | 作用 |
|--------|------|------|------|
| seq | unsigned char | 1字节 | 序列号，取值为0或1，用于实现停等协议的交替比特机制，标识当前数据帧的序号 |
| data | char[1024] | 1024字节 | 数据字段，存储实际传输的数据内容 |
| flag | unsigned char | 1字节 | 标志位，0表示普通数据帧，1表示最后一个数据帧（结束帧），用于通知接收方传输结束 |

**总大小：** 1026字节

### 2.2 确认分组格式

#### ACK帧结构（AckFrame）

```cpp
struct AckFrame {
    unsigned char ack;      // ACK序列号
};
```

**域作用说明：**

| 字段名 | 类型 | 大小 | 作用 |
|--------|------|------|------|
| ack | unsigned char | 1字节 | 确认序列号，取值为0或1，表示对相应序列号数据帧的确认 |

**总大小：** 1字节

### 2.3 协议工作原理

停等协议采用**交替比特协议（Alternating Bit Protocol）**机制：

1. **序列号机制：** 使用0和1两个序列号交替标识数据帧
2. **确认机制：** 接收方发送与数据帧序列号相同的ACK确认
3. **超时重传：** 发送方在超时时间（2秒）内未收到正确ACK则重传
4. **重复检测：** 接收方通过序列号检测并丢弃重复数据帧
5. **结束标志：** 使用flag字段标识最后一个数据帧

## 三、程序流程图

### 3.1 服务器端流程图

```mermaid
flowchart TD
    Start([开始]) --> Init[初始化Winsock]
    Init --> CreateSocket[创建UDP Socket]
    CreateSocket --> BindPort[绑定端口12340]
    BindPort --> SetLossRate[设置ACK丢包率]
    SetLossRate --> WaitRequest[等待客户端请求]

    WaitRequest --> RecvCmd{接收命令}
    RecvCmd -->|"-time"| SendTime[发送服务器时间]
    RecvCmd -->|"-quit"| SendBye[发送Good bye]
    RecvCmd -->|"-test"| StartTest[开始停等协议测试]
    RecvCmd -->|其他| Echo[回显数据]

    SendTime --> WaitRequest
    Echo --> WaitRequest
    SendBye --> WaitRequest

    StartTest --> InitSeq[初始化序列号seq=0]
    InitSeq --> PrepareData[准备测试数据包]
    PrepareData --> SendLoop{遍历数据包}

    SendLoop -->|有数据| BuildFrame[构建DataFrame]
    BuildFrame --> SendFrame[发送数据帧]
    SendFrame --> WaitACK[等待ACK超时2秒]

    WaitACK -->|超时| CheckRetry{检查重传次数}
    CheckRetry -->|<5次| SendFrame
    CheckRetry -->|>=5次| SendFail[发送失败]

    WaitACK -->|收到数据| SimulateLoss{模拟ACK丢失?}
    SimulateLoss -->|是| CheckRetry
    SimulateLoss -->|否| CheckACK{ACK正确?}

    CheckACK -->|正确| ToggleSeq[切换序列号seq=1-seq]
    CheckACK -->|错误| CheckRetry

    ToggleSeq --> SendLoop
    SendLoop -->|无数据| Complete[传输完成]
    SendFail --> WaitRequest
    Complete --> WaitRequest

    style Start fill:#90EE90
    style Complete fill:#87CEEB
    style SendFail fill:#FFB6C1
```

### 3.2 服务器端sendDataFrame函数流程图

```mermaid
flowchart TD
    FuncStart([sendDataFrame函数开始]) --> InitAttempts[初始化重传次数attempts=0]
    InitAttempts --> CopyFrame[复制DataFrame到缓冲区]

    CopyFrame --> CheckAttempts{attempts < MAX_ATTEMPTS?}
    CheckAttempts -->|否| ReturnFalse[返回false - 失败]
    CheckAttempts -->|是| SendData[使用sendto发送数据帧]

    SendData --> CheckSendError{发送成功?}
    CheckSendError -->|失败| ReturnFalse
    CheckSendError -->|成功| PrintSend[打印发送信息]

    PrintSend --> SetupSelect[设置select监听]
    SetupSelect --> SelectWait[select等待2秒超时]

    SelectWait --> CheckSelect{select结果?}
    CheckSelect -->|错误| IncrementAttempts
    CheckSelect -->|超时| PrintTimeout[打印超时信息]
    PrintTimeout --> IncrementAttempts[attempts++]
    IncrementAttempts --> CheckAttempts

    CheckSelect -->|有数据| RecvACK[接收ACK帧]
    RecvACK --> PrintRecvACK[打印接收的ACK]

    PrintRecvACK --> CheckLastFrame{是否最后一帧?}
    CheckLastFrame -->|是| CheckACKSeq
    CheckLastFrame -->|否| SimACKLoss{模拟ACK丢失?}

    SimACKLoss -->|是| PrintSimLoss[打印ACK丢失信息]
    PrintSimLoss --> IncrementAttempts
    SimACKLoss -->|否| CheckACKSeq{ACK序列号正确?}

    CheckACKSeq -->|正确| PrintSuccess[打印成功信息]
    PrintSuccess --> ReturnTrue[返回true - 成功]
    CheckACKSeq -->|错误| PrintMismatch[打印ACK不匹配]
    PrintMismatch --> IncrementAttempts

    style FuncStart fill:#90EE90
    style ReturnTrue fill:#87CEEB
    style ReturnFalse fill:#FFB6C1
```

### 3.3 客户端流程图

```mermaid
flowchart TD
    Start([开始]) --> Init[初始化Winsock]
    Init --> CreateSocket[创建UDP Socket]
    CreateSocket --> SetServer[设置服务器地址127.0.0.1:12340]
    SetServer --> ShowMenu[显示命令菜单]
    ShowMenu --> WaitInput[等待用户输入命令]

    WaitInput --> ParseCmd{解析命令}
    ParseCmd -->|"-time"| ReqTime[请求服务器时间]
    ParseCmd -->|"-quit"| ReqQuit[请求退出]
    ParseCmd -->|"-test"| StartTest[开始测试停等协议]
    ParseCmd -->|其他| EchoTest[回显测试]

    ReqTime --> RecvTime[接收并显示时间]
    RecvTime --> WaitInput

    EchoTest --> RecvEcho[接收并显示回显]
    RecvEcho --> WaitInput

    ReqQuit --> RecvBye[接收Good bye消息]
    RecvBye --> Cleanup[清理资源]
    Cleanup --> End([结束])

    StartTest --> ParseParams[解析丢包率参数]
    ParseParams --> SetLoss[设置数据丢包率和ACK丢包率]
    SetLoss --> SendTestCmd[发送-test命令]
    SendTestCmd --> InitExpSeq[初始化期望序列号expectedSeq=0]
    InitExpSeq --> RecvLoop[进入接收循环]

    RecvLoop --> RecvFrame[接收DataFrame设置10秒超时]
    RecvFrame --> CheckRecv{接收结果?}

    CheckRecv -->|超时| PrintStats[打印统计信息]
    PrintStats --> WaitInput

    CheckRecv -->|错误| HandleError[处理错误]
    HandleError --> WaitInput

    CheckRecv -->|成功| PrintRecv[打印接收信息]
    PrintRecv --> SimDataLoss{模拟数据丢失?}

    SimDataLoss -->|是| PrintDataLoss[打印数据丢失不发ACK]
    PrintDataLoss --> RecvLoop

    SimDataLoss -->|否| CheckSeq{序列号匹配?}

    CheckSeq -->|匹配| PrintMatch[打印序列号匹配]
    PrintMatch --> SimACKLoss{模拟ACK丢失?}

    SimACKLoss -->|是| PrintACKLoss[打印ACK丢失不发ACK]
    PrintACKLoss --> RecvLoop

    SimACKLoss -->|否| SendACK[发送ACK帧]
    SendACK --> IncCount[receivedCount++]
    IncCount --> UpdateExpSeq[更新expectedSeq=1-expectedSeq]
    UpdateExpSeq --> CheckEnd{flag==1?}

    CheckEnd -->|是| PrintComplete[打印传输完成]
    PrintComplete --> PrintFinalStats[打印最终统计]
    PrintFinalStats --> WaitInput

    CheckEnd -->|否| RecvLoop

    CheckSeq -->|不匹配| PrintDup[打印重复数据包信息]
    PrintDup --> IncDupCount[duplicateCount++]
    IncDupCount --> SimACKLoss2{模拟ACK丢失?}

    SimACKLoss2 -->|是| PrintACKLoss2[打印ACK丢失]
    PrintACKLoss2 --> RecvLoop
    SimACKLoss2 -->|否| ResendACK[重发上一个ACK=1-expectedSeq]
    ResendACK --> RecvLoop

    style Start fill:#90EE90
    style End fill:#87CEEB
    style PrintStats fill:#FFD700
    style PrintFinalStats fill:#FFD700
```

## 四、协议典型交互过程

### 4.1 正常传输场景（无丢包）

```mermaid
sequenceDiagram
    participant C as 客户端
    participant S as 服务器

    Note over C,S: 客户端发送-test命令启动测试
    C->>S: -test命令

    Note over S: 准备数据包1, Seq=0
    S->>C: DataFrame(Seq=0, Data="数据包1", Flag=0)
    Note over C: 接收Seq=0，序列号匹配
    C->>S: ACK(Ack=0)
    Note over S: 收到ACK=0，确认成功

    Note over S: 准备数据包2, Seq=1
    S->>C: DataFrame(Seq=1, Data="数据包2", Flag=0)
    Note over C: 接收Seq=1，序列号匹配
    C->>S: ACK(Ack=1)
    Note over S: 收到ACK=1，确认成功

    Note over S: 准备数据包3, Seq=0
    S->>C: DataFrame(Seq=0, Data="数据包3", Flag=0)
    Note over C: 接收Seq=0，序列号匹配
    C->>S: ACK(Ack=0)
    Note over S: 收到ACK=0，确认成功

    Note over S: 准备最后数据包, Seq=1
    S->>C: DataFrame(Seq=1, Data="最后包", Flag=1)
    Note over C: 接收Seq=1，检测到Flag=1
    C->>S: ACK(Ack=1)
    Note over S: 收到ACK=1，传输完成
    Note over C: 传输完成，打印统计信息
```

### 4.2 数据包丢失场景

```mermaid
sequenceDiagram
    participant C as 客户端
    participant S as 服务器

    Note over S: 准备数据包1, Seq=0
    S->>C: DataFrame(Seq=0, Data="数据包1", Flag=0)
    Note over C: 模拟丢包，不发送ACK
    Note over S: 等待2秒超时
    Note over S: 超时，准备重传
    S->>C: DataFrame(Seq=0, Data="数据包1", Flag=0)
    Note over C: 接收Seq=0，序列号匹配
    C->>S: ACK(Ack=0)
    Note over S: 收到ACK=0，确认成功

    Note over S: 切换序列号，准备数据包2, Seq=1
    S->>C: DataFrame(Seq=1, Data="数据包2", Flag=0)
    Note over C: 接收Seq=1，序列号匹配
    C->>S: ACK(Ack=1)
    Note over S: 收到ACK=1，确认成功
```

### 4.3 ACK丢失场景

```mermaid
sequenceDiagram
    participant C as 客户端
    participant S as 服务器

    Note over S: 准备数据包1, Seq=0
    S->>C: DataFrame(Seq=0, Data="数据包1", Flag=0)
    Note over C: 接收Seq=0，序列号匹配
    C->>S: ACK(Ack=0)
    Note over S: 模拟ACK丢失，假装未收到
    Note over S: 等待2秒超时
    Note over S: 超时，准备重传
    S->>C: DataFrame(Seq=0, Data="数据包1", Flag=0)
    Note over C: 接收Seq=0，但期望Seq=1
    Note over C: 检测到重复数据包，丢弃数据
    C->>S: ACK(Ack=0) - 重发上一个ACK
    Note over S: 收到ACK=0，确认成功

    Note over S: 切换序列号，准备数据包2, Seq=1
    S->>C: DataFrame(Seq=1, Data="数据包2", Flag=0)
    Note over C: 接收Seq=1，序列号匹配
    C->>S: ACK(Ack=1)
    Note over S: 收到ACK=1，确认成功
```

### 4.4 交互过程说明

**关键步骤：**

1. **初始化阶段：**
   - 客户端发送`-test`命令启动停等协议测试
   - 服务器准备测试数据并初始化序列号为0

2. **正常传输：**
   - 服务器发送Seq=0的数据帧
   - 客户端收到后验证序列号，发送ACK=0
   - 服务器收到正确ACK后切换序列号为1
   - 重复上述过程，序列号在0和1之间交替

3. **数据包丢失处理：**
   - 客户端模拟丢包，不发送ACK
   - 服务器超时（2秒）后重传相同序列号的数据帧
   - 客户端收到后发送ACK
   - 服务器确认后继续下一个数据包

4. **ACK丢失处理：**
   - 客户端发送ACK，但服务器模拟ACK丢失
   - 服务器超时后重传相同序列号的数据帧
   - 客户端检测到重复数据（序列号不匹配），丢弃数据但重发ACK
   - 服务器收到ACK后继续

5. **传输结束：**
   - 服务器发送最后一个数据帧（Flag=1）
   - 客户端收到后发送ACK并结束接收
   - 打印传输统计信息

## 五、数据分组丢失验证模拟方法

### 5.1 数据包丢失模拟（客户端）

**实现位置：** `client.cpp:34-38`

```cpp
bool simulateLoss() {
    if (lossRate <= 0.0f) return false;
    float random = (float)rand() / RAND_MAX;
    return random < lossRate;
}
```

**模拟方法：**

1. **丢包率设置：** 用户通过`-test [数据丢包率] [ACK丢包率]`命令设置，默认数据丢包率为0.2（20%）
2. **随机数生成：** 使用`rand()`生成0到1之间的随机浮点数
3. **丢包判断：** 如果随机数小于设置的丢包率，则模拟丢包
4. **丢包行为：** 客户端收到数据帧后，如果判断为丢包，则不发送ACK确认（`client.cpp:201-204`）

**代码实现（client.cpp:200-204）：**
```cpp
// 模拟丢包
if (simulateLoss()) {
    cout << "[模拟] 数据包丢失! 不发送ACK" << endl;
    continue;
}
```

**验证效果：**
- 服务器在超时时间（2秒）内未收到ACK
- 服务器打印`[超时] 未收到ACK, 准备重传...`
- 服务器重传相同序列号的数据帧
- 客户端接收到重传的数据帧后正常发送ACK

### 5.2 ACK丢失模拟

#### 5.2.1 服务器端ACK丢失模拟

**实现位置：** `server.cpp:32-36`

```cpp
bool simulateAckLoss() {
    if (ackLossRate <= 0.0f) return false;
    float random = (float)rand() / RAND_MAX;
    return random < ackLossRate;
}
```

**模拟方法：**

1. **丢包率设置：** 服务器启动时设置ACK丢包率，默认为0.2（20%）
2. **模拟时机：** 服务器实际收到ACK后，通过随机数判断是否模拟丢失
3. **丢包行为：** 如果判断为丢失，服务器假装未收到ACK，继续等待或重传（`server.cpp:101-105`）

**代码实现（server.cpp:101-105）：**
```cpp
// 模拟ACK丢失(服务器收到ACK但假装没收到)
if (!isLastFrame && simulateAckLoss()) {
    cout << "[模拟] ACK丢失! 假装未收到ACK" << endl;
    attempts++;
    continue;
}
```

**注意事项：**
- 最后一个数据包不模拟ACK丢失（`!isLastFrame`条件），因为客户端已经结束接收

#### 5.2.2 客户端ACK发送丢失模拟

**实现位置：** `client.cpp:41-45` 和 `client.cpp:211-214`, `client.cpp:246-249`

**模拟方法：**

1. **正常接收时的ACK丢失：** 客户端正确接收数据后，模拟ACK丢失不发送ACK
2. **重复数据时的ACK丢失：** 客户端检测到重复数据后，模拟重发ACK的丢失

**代码实现（client.cpp:210-215）：**
```cpp
// 模拟ACK丢失
if (simulateAckLoss()) {
    cout << "[模拟] ACK丢失! 不发送ACK" << endl;
    continue;
}
```

**验证效果：**
- 服务器超时后重传数据帧
- 客户端收到重复数据帧（序列号不匹配）
- 客户端丢弃重复数据但重发ACK
- duplicateCount计数器增加

### 5.3 超时机制

**服务器端超时设置：** `server.cpp:14`
```cpp
#define TIMEOUT_MS 2000  // 超时时间2秒
```

**超时实现方法：** 使用`select()`函数实现非阻塞等待（`server.cpp:84-89`）

```cpp
timeval timeout;
timeout.tv_sec = TIMEOUT_MS / 1000;        // 2秒
timeout.tv_usec = (TIMEOUT_MS % 1000) * 1000;
int selectResult = select(0, &readSet, NULL, NULL, &timeout);
```

**超时处理流程：**
1. 发送数据帧后，设置2秒超时等待ACK
2. 如果在2秒内收到ACK，验证序列号并继续
3. 如果超时未收到ACK，打印超时信息并重传
4. 最多重传5次（`server.cpp:60`），超过则报告失败

### 5.4 丢包统计

**客户端统计信息：** `client.cpp:180-181`

```cpp
int receivedCount = 0;    // 已接收数据包计数
int duplicateCount = 0;   // 重复数据包计数
```

**统计输出（client.cpp:232-235）：**
```cpp
cout << "统计信息:" << endl;
cout << "  成功接收数据包: " << receivedCount << " 个" << endl;
cout << "  重复数据包: " << duplicateCount << " 个" << endl;
```

通过统计信息可以验证：
- **receivedCount：** 应等于服务器发送的实际数据包数量（5个）
- **duplicateCount：** 反映了重传次数，验证了丢包和重传机制的有效性

## 六、程序实现的主要类（或函数）及其主要作用

### 6.1 服务器端（server.cpp）

#### 6.1.1 数据结构

| 结构体/变量 | 定义位置 | 作用 |
|------------|----------|------|
| `DataFrame` | server.cpp:17-21 | 定义数据帧结构，包含序列号、数据和标志位 |
| `AckFrame` | server.cpp:24-26 | 定义ACK帧结构，包含ACK序列号 |
| `ackLossRate` | server.cpp:29 | 全局变量，存储ACK丢包率 |

#### 6.1.2 主要函数

##### 1. `bool simulateAckLoss()`
- **位置：** server.cpp:32-36
- **参数：** 无
- **返回值：** bool - true表示模拟丢失，false表示不丢失
- **作用：** 根据设置的ACK丢包率，使用随机数模拟ACK丢失场景
- **调用时机：** 服务器接收到ACK后判断是否模拟丢失

##### 2. `string getCurrentTime()`
- **位置：** server.cpp:39-45
- **参数：** 无
- **返回值：** string - 当前时间的字符串表示
- **作用：** 获取当前系统时间并格式化为字符串，用于响应客户端的-time命令
- **实现方式：** 使用`time()`和`ctime()`函数

##### 3. `bool sendDataFrame(SOCKET sock, sockaddr_in& clientAddr, DataFrame& frame, int expectedAck, bool isLastFrame)`
- **位置：** server.cpp:55-127
- **参数：**
  - `sock`: UDP套接字
  - `clientAddr`: 客户端地址结构
  - `frame`: 要发送的数据帧
  - `expectedAck`: 期望收到的ACK序列号
  - `isLastFrame`: 是否为最后一帧（默认false）
- **返回值：** bool - true表示发送成功，false表示失败
- **作用：** 实现停等协议的核心逻辑，发送数据帧并等待确认，包含超时重传机制
- **主要流程：**
  1. 发送数据帧到客户端
  2. 使用`select()`设置2秒超时等待ACK
  3. 收到ACK后验证序列号是否匹配
  4. 模拟ACK丢失（非最后一帧）
  5. 超时或ACK错误则重传，最多重传5次
  6. 成功收到正确ACK返回true

##### 4. `int main()`
- **位置：** server.cpp:129-285
- **参数：** 无
- **返回值：** int - 程序退出码
- **作用：** 服务器主函数，实现服务器的完整生命周期
- **主要流程：**
  1. 初始化Winsock库（`WSAStartup`）
  2. 创建UDP套接字（`socket`）
  3. 绑定端口12340（`bind`）
  4. 设置ACK丢包率
  5. 进入主循环，等待并处理客户端请求：
     - `-time`：返回当前时间
     - `-quit`：发送Good bye消息
     - `-test`：启动停等协议测试，发送5个测试数据包
     - 其他：回显数据
  6. 清理资源

### 6.2 客户端（client.cpp）

#### 6.2.1 数据结构

| 结构体/变量 | 定义位置 | 作用 |
|------------|----------|------|
| `DataFrame` | client.cpp:18-22 | 定义数据帧结构（与服务器端一致） |
| `AckFrame` | client.cpp:25-27 | 定义ACK帧结构（与服务器端一致） |
| `lossRate` | client.cpp:30 | 全局变量，存储数据包丢包率 |
| `ackLossRate` | client.cpp:31 | 全局变量，存储ACK丢包率 |

#### 6.2.2 主要函数

##### 1. `bool simulateLoss()`
- **位置：** client.cpp:34-38
- **参数：** 无
- **返回值：** bool - true表示模拟丢失，false表示不丢失
- **作用：** 根据设置的数据丢包率，使用随机数模拟数据包丢失场景
- **调用时机：** 客户端接收到数据帧后判断是否模拟丢失

##### 2. `bool simulateAckLoss()`
- **位置：** client.cpp:41-45
- **参数：** 无
- **返回值：** bool - true表示模拟丢失，false表示不丢失
- **作用：** 根据设置的ACK丢包率，使用随机数模拟ACK发送丢失场景
- **调用时机：** 客户端准备发送ACK前判断是否模拟丢失

##### 3. `int main()`
- **位置：** client.cpp:47-304
- **参数：** 无
- **返回值：** int - 程序退出码
- **作用：** 客户端主函数，实现客户端的完整生命周期
- **主要流程：**
  1. 初始化Winsock库
  2. 创建UDP套接字
  3. 设置服务器地址（127.0.0.1:12340）
  4. 显示命令菜单
  5. 进入主循环，处理用户命令：
     - `-time`：请求并显示服务器时间
     - `-quit`：退出程序
     - `-test [数据丢包率] [ACK丢包率]`：启动停等协议测试
     - 其他：回显测试
  6. **-test命令处理流程（核心部分）：**
     - 解析并设置丢包率参数
     - 发送`-test`命令到服务器
     - 初始化期望序列号`expectedSeq=0`
     - 循环接收数据帧（设置10秒超时）：
       - 模拟数据包丢失
       - 验证序列号是否匹配
       - 匹配则发送ACK并更新期望序列号
       - 不匹配则丢弃数据并重发上一个ACK
       - 检测结束标志（flag==1）
     - 打印统计信息（成功接收数据包数、重复数据包数）
  7. 清理资源

### 6.3 关键函数调用关系

```
服务器端调用链：
main()
├── WSAStartup()              # Winsock初始化
├── socket()                  # 创建UDP套接字
├── bind()                    # 绑定端口
├── recvfrom()                # 接收客户端命令
├── getCurrentTime()          # 处理-time命令
└── sendDataFrame()           # 处理-test命令，发送数据帧
    ├── sendto()              # 发送数据帧
    ├── select()              # 等待ACK超时
    ├── recvfrom()            # 接收ACK
    └── simulateAckLoss()     # 模拟ACK丢失

客户端调用链：
main()
├── WSAStartup()              # Winsock初始化
├── socket()                  # 创建UDP套接字
├── sendto()                  # 发送命令到服务器
└── [处理-test命令]
    ├── recvfrom()            # 接收数据帧
    ├── simulateLoss()        # 模拟数据包丢失
    ├── simulateAckLoss()     # 模拟ACK丢失
    └── sendto()              # 发送ACK
```

## 七、UDP编程的主要特点

### 7.1 UDP协议特点

| 特点 | 说明 | 本实验体现 |
|------|------|-----------|
| **无连接** | 发送数据前不需要建立连接 | 客户端直接向服务器发送数据，无需三次握手 |
| **不可靠传输** | 不保证数据包按序到达，可能丢失或重复 | 需要自行实现停等协议保证可靠性 |
| **面向数据报** | 保留消息边界，一次发送一个数据报 | 每次`sendto()`发送一个完整的DataFrame |
| **无流量控制** | 不提供拥塞控制和流量控制 | 通过停等协议隐式实现简单的流量控制 |
| **无状态** | 不维护连接状态信息 | 每次通信都需要指定对方地址 |
| **轻量高效** | 协议头部开销小，处理速度快 | 适合简单的请求-响应模式 |

### 7.2 UDP Socket编程主要API

#### 7.2.1 初始化和清理

```cpp
// Windows平台初始化Winsock
WSADATA wsaData;
WSAStartup(MAKEWORD(2, 2), &wsaData);

// 清理Winsock
WSACleanup();
```

**作用：** Windows平台特有，初始化网络库

#### 7.2.2 创建套接字

```cpp
SOCKET sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
```

**参数说明：**
- `AF_INET`: IPv4地址族
- `SOCK_DGRAM`: 数据报套接字（UDP）
- `IPPROTO_UDP`: UDP协议

**本实验使用：**
- 服务器：server.cpp:141
- 客户端：client.cpp:59

#### 7.2.3 绑定地址（服务器端）

```cpp
sockaddr_in serverAddr;
serverAddr.sin_family = AF_INET;
serverAddr.sin_addr.s_addr = INADDR_ANY;  // 监听所有网卡
serverAddr.sin_port = htons(SERVER_PORT);  // 网络字节序

bind(serverSocket, (sockaddr*)&serverAddr, sizeof(serverAddr));
```

**作用：** 将套接字绑定到特定端口，用于接收数据

**本实验使用：** server.cpp:149-158

#### 7.2.4 发送数据

```cpp
int sendto(
    SOCKET sock,                  // 套接字
    const char* buffer,           // 数据缓冲区
    int len,                      // 数据长度
    int flags,                    // 标志（通常为0）
    const struct sockaddr* to,    // 目标地址
    int tolen                     // 地址长度
);
```

**特点：** 每次发送都需要指定目标地址

**本实验使用：**
- 服务器发送数据帧：server.cpp:64-65
- 客户端发送ACK：client.cpp:219-220

#### 7.2.5 接收数据

```cpp
int recvfrom(
    SOCKET sock,                  // 套接字
    char* buffer,                 // 接收缓冲区
    int len,                      // 缓冲区大小
    int flags,                    // 标志（通常为0）
    struct sockaddr* from,        // 发送方地址（输出参数）
    int* fromlen                  // 地址长度（输入输出参数）
);
```

**特点：** 接收到的数据会包含发送方的地址信息

**本实验使用：**
- 服务器接收ACK：server.cpp:93-94
- 客户端接收数据帧：client.cpp:193-194

#### 7.2.6 设置超时（客户端）

```cpp
DWORD timeout = 10000;  // 10秒，单位毫秒
setsockopt(clientSocket, SOL_SOCKET, SO_RCVTIMEO,
           (char*)&timeout, sizeof(timeout));
```

**作用：** 设置接收超时时间，防止无限等待

**本实验使用：** client.cpp:189-191

#### 7.2.7 非阻塞等待（服务器端）

```cpp
fd_set readSet;
FD_ZERO(&readSet);
FD_SET(sock, &readSet);

timeval timeout;
timeout.tv_sec = 2;
timeout.tv_usec = 0;

int result = select(0, &readSet, NULL, NULL, &timeout);
```

**作用：** 在指定时间内等待套接字可读，实现超时机制

**本实验使用：** server.cpp:80-89

### 7.3 UDP与TCP的对比

| 特性 | UDP | TCP |
|------|-----|-----|
| 连接方式 | 无连接 | 面向连接 |
| 可靠性 | 不可靠，需自行实现 | 可靠传输（确认、重传、排序） |
| 数据边界 | 保留消息边界 | 字节流，无消息边界 |
| 传输效率 | 高（无握手、无确认） | 较低（握手、确认、流控） |
| 头部开销 | 8字节 | 20字节（最小） |
| 适用场景 | 实时应用（视频、游戏）、DNS | 文件传输、HTTP、FTP |
| 本实验选择 | 便于实现和演示自定义可靠传输协议 | - |

### 7.4 本实验中UDP编程的关键点

#### 7.4.1 地址管理

```cpp
// 服务器需要记录客户端地址以便回复
sockaddr_in clientAddr;
int clientAddrLen = sizeof(clientAddr);
recvfrom(serverSocket, buffer, size, 0, (sockaddr*)&clientAddr, &clientAddrLen);
// 使用clientAddr回复
sendto(serverSocket, data, len, 0, (sockaddr*)&clientAddr, clientAddrLen);
```

**特点：** UDP无连接，每次通信都需要明确指定对方地址

#### 7.4.2 超时控制

**服务器使用select()：**
```cpp
timeval timeout;
timeout.tv_sec = TIMEOUT_MS / 1000;
timeout.tv_usec = (TIMEOUT_MS % 1000) * 1000;
select(0, &readSet, NULL, NULL, &timeout);
```

**客户端使用setsockopt()：**
```cpp
DWORD timeout = 10000;
setsockopt(clientSocket, SOL_SOCKET, SO_RCVTIMEO, (char*)&timeout, sizeof(timeout));
```

**原因：** UDP不提供超时机制，需要应用层实现

#### 7.4.3 数据完整性

```cpp
// 一次性接收整个数据帧
recvfrom(sock, (char*)&frame, sizeof(DataFrame), 0, ...);
```

**特点：** UDP保留消息边界，一次接收完整数据报，不会出现TCP的粘包问题

#### 7.4.4 错误处理

```cpp
if (sendResult == SOCKET_ERROR) {
    cout << "[错误] 发送失败: " << WSAGetLastError() << endl;
}
```

**特点：** UDP发送成功只表示数据已提交给网络层，不保证对方收到

### 7.5 UDP编程的优缺点

#### 优点：
1. **简单高效：** 无需建立连接，协议开销小
2. **实时性好：** 无重传和流控，延迟低
3. **支持广播和组播：** 适合一对多通信
4. **灵活性高：** 应用层可自行实现所需的可靠性机制

#### 缺点：
1. **不可靠：** 需要应用层实现可靠性保证
2. **无序：** 数据包可能乱序到达
3. **无流控：** 可能导致接收方缓冲区溢出
4. **不适合大数据传输：** MTU限制，大数据需要分片

#### 本实验的应对：
- **可靠性：** 实现停等协议，保证数据按序可靠到达
- **超时重传：** 解决数据包和ACK丢失问题
- **序列号机制：** 检测和丢弃重复数据包
- **结束标志：** 明确标识传输结束

## 八、实验验证结果

### 8.1 测试环境

- **操作系统：** Windows
- **编译器：** MSVC (Visual Studio)
- **测试方式：** 本地回环测试（127.0.0.1）
- **测试数据：** 5个测试数据包

### 8.2 测试场景

#### 8.2.1 场景1：无丢包测试

**配置：**
- 数据丢包率：0.0
- ACK丢包率：0.0

**预期结果：**
- 所有数据包一次发送成功
- 无重传
- 无重复数据包

**实际结果：**
```
[开始] 停等协议测试
数据包丢包率: 0%
ACK丢包率: 0%

--- 发送数据包 1/5 ---
[发送] Seq=0, 数据大小=24 字节, 尝试次数=1
[接收] ACK=0
[成功] 收到正确ACK

[接收] Seq=0, 数据="这是第一个数据包"
[正确] 序列号匹配, 准备发送ACK=0
[发送] ACK=0

--- 发送数据包 2/5 ---
[发送] Seq=1, 数据大小=24 字节, 尝试次数=1
[接收] ACK=1
[成功] 收到正确ACK

[接收] Seq=1, 数据="这是第二个数据包"
[正确] 序列号匹配, 准备发送ACK=1
[发送] ACK=1

... (后续数据包类似)

[完成] 收到结束标志, 传输完成!
统计信息:
  成功接收数据包: 5 个
  重复数据包: 0 个
```

**验证结论：** ✅ 正常场景下协议工作正常，无重传

#### 8.2.2 场景2：数据包丢失测试

**配置：**
- 数据丢包率：0.3 (30%)
- ACK丢包率：0.0

**预期结果：**
- 部分数据包会被客户端模拟丢失
- 服务器超时后重传
- 重传的数据包能够成功接收
- 最终所有数据包正确接收

**实际结果：**
```
[开始] 停等协议测试
数据包丢包率: 30%
ACK丢包率: 0%

--- 发送数据包 1/5 ---
[发送] Seq=0, 数据大小=24 字节, 尝试次数=1

[接收] Seq=0, 数据="这是第一个数据包"
[模拟] 数据包丢失! 不发送ACK

[超时] 未收到ACK, 准备重传...
[发送] Seq=0, 数据大小=24 字节, 尝试次数=2

[接收] Seq=0, 数据="这是第一个数据包"
[正确] 序列号匹配, 准备发送ACK=0
[发送] ACK=0

[接收] ACK=0
[成功] 收到正确ACK

--- 发送数据包 2/5 ---
[发送] Seq=1, 数据大小=24 字节, 尝试次数=1
...

[完成] 收到结束标志, 传输完成!
统计信息:
  成功接收数据包: 5 个
  重复数据包: 0 个
```

**验证结论：** ✅ 数据包丢失场景下，超时重传机制正常工作

#### 8.2.3 场景3：ACK丢失测试

**配置：**
- 数据丢包率：0.0
- ACK丢包率：0.3 (30%)

**预期结果：**
- 部分ACK会被模拟丢失
- 服务器超时后重传数据包
- 客户端检测到重复数据包，丢弃数据但重发ACK
- duplicateCount计数器增加

**实际结果：**
```
[开始] 停等协议测试
数据包丢包率: 0%
ACK丢包率: 30%

--- 发送数据包 1/5 ---
[发送] Seq=0, 数据大小=24 字节, 尝试次数=1

[接收] Seq=0, 数据="这是第一个数据包"
[正确] 序列号匹配, 准备发送ACK=0
[发送] ACK=0

[接收] ACK=0
[模拟] ACK丢失! 假装未收到ACK

[超时] 未收到ACK, 准备重传...
[发送] Seq=0, 数据大小=24 字节, 尝试次数=2

[接收] Seq=0, 数据="这是第一个数据包"
[重复] 序列号不匹配! 期望=1, 实际=0
[重复] 这是重复的数据包, 丢弃数据
[重发] 重发上一个ACK=0

[接收] ACK=0
[成功] 收到正确ACK

--- 发送数据包 2/5 ---
...

[完成] 收到结束标志, 传输完成!
统计信息:
  成功接收数据包: 5 个
  重复数据包: 2 个
```

**验证结论：** ✅ ACK丢失场景下，重传机制和重复检测机制正常工作

#### 8.2.4 场景4：混合丢包测试

**配置：**
- 数据丢包率：0.2 (20%)
- ACK丢包率：0.2 (20%)

**预期结果：**
- 同时出现数据包丢失和ACK丢失
- 协议能够处理各种组合情况
- 最终所有数据正确传输

**实际结果：**
```
[开始] 停等协议测试
数据包丢包率: 20%
ACK丢包率: 20%

--- 发送数据包 1/5 ---
[发送] Seq=0, 数据大小=24 字节, 尝试次数=1
[接收] Seq=0, 数据="这是第一个数据包"
[正确] 序列号匹配, 准备发送ACK=0
[模拟] ACK丢失! 不发送ACK

[超时] 未收到ACK, 准备重传...
[发送] Seq=0, 数据大小=24 字节, 尝试次数=2
[接收] Seq=0, 数据="这是第一个数据包"
[重复] 序列号不匹配! 期望=1, 实际=0
[重发] 重发上一个ACK=0
[接收] ACK=0
[成功] 收到正确ACK

--- 发送数据包 2/5 ---
[发送] Seq=1, 数据大小=24 字节, 尝试次数=1
[接收] Seq=1, 数据="这是第二个数据包"
[模拟] 数据包丢失! 不发送ACK

[超时] 未收到ACK, 准备重传...
[发送] Seq=1, 数据大小=24 字节, 尝试次数=2
[接收] Seq=1, 数据="这是第二个数据包"
[正确] 序列号匹配, 准备发送ACK=1
[发送] ACK=1
[接收] ACK=1
[成功] 收到正确ACK

...

[完成] 收到结束标志, 传输完成!
统计信息:
  成功接收数据包: 5 个
  重复数据包: 3 个
```

**验证结论：** ✅ 混合丢包场景下，协议仍能保证数据可靠传输

### 8.3 性能统计

| 测试场景 | 数据丢包率 | ACK丢包率 | 发送总次数 | 重复数据包 | 传输成功 |
|---------|-----------|----------|-----------|-----------|---------|
| 无丢包 | 0% | 0% | 5 | 0 | ✅ |
| 数据丢包 | 30% | 0% | 7-9 | 0 | ✅ |
| ACK丢包 | 0% | 30% | 6-8 | 1-3 | ✅ |
| 混合丢包 | 20% | 20% | 8-12 | 2-5 | ✅ |

### 8.4 异常场景测试

#### 8.4.1 极端丢包率测试（80%）

**配置：**
- 数据丢包率：0.8
- ACK丢包率：0.8

**结果：**
- 部分数据包需要多次重传（3-5次）
- 传输时间显著增加
- 最终仍能成功传输（未达到最大重传次数5次）

**验证结论：** ✅ 极端情况下协议仍然可靠，但效率降低

#### 8.4.2 超过最大重传次数

**模拟方式：** 临时修改最大重传次数为1，设置丢包率为0.9

**结果：**
```
[失败] 达到最大重传次数
[失败] 数据包发送失败
```

**验证结论：** ✅ 达到最大重传次数后正确报告失败

### 8.5 其他功能测试

#### 8.5.1 时间查询功能

**测试命令：** `-time`

**结果：**
```
[服务器时间] Thu Oct 23 20:15:32 2025
```

**验证结论：** ✅ 基本UDP通信功能正常

#### 8.5.2 回显功能

**测试命令：** `Hello Server`

**结果：**
```
[回显] Hello Server
```

**验证结论：** ✅ 基本UDP通信功能正常

#### 8.5.3 退出功能

**测试命令：** `-quit`

**结果：**
```
[服务器] Good bye!
客户端已关闭
```

**验证结论：** ✅ 正常退出机制工作正常

### 8.6 实验总结

#### 8.6.1 成功验证的功能

1. ✅ **停等协议基本功能：** 序列号交替、确认机制正常工作
2. ✅ **数据包丢失处理：** 超时重传机制有效
3. ✅ **ACK丢失处理：** 重复数据包检测和重发ACK机制正确
4. ✅ **混合丢包处理：** 能够同时处理数据包和ACK丢失
5. ✅ **结束标志：** 正确识别传输结束
6. ✅ **统计信息：** 准确统计接收和重复数据包数量

#### 8.6.2 协议特性验证

| 特性 | 验证方法 | 结果 |
|------|---------|------|
| 可靠性 | 模拟各种丢包场景 | ✅ 所有场景下数据最终正确传输 |
| 按序交付 | 检查接收序列号 | ✅ 序列号严格按0→1→0...交替 |
| 去重 | 统计重复数据包 | ✅ 正确检测并丢弃重复数据 |
| 超时重传 | 观察超时和重传行为 | ✅ 2秒超时后正确重传 |
| 最大重传限制 | 极端丢包率测试 | ✅ 达到5次后报告失败 |

#### 8.6.3 实验结论

本实验成功实现了基于UDP的停等协议，验证了以下关键点：

1. **UDP可以实现可靠传输：** 通过应用层协议（停等）弥补UDP的不可靠性
2. **超时重传机制有效：** 能够应对数据包和ACK丢失
3. **序列号机制简单有效：** 仅使用0和1两个序列号即可实现可靠传输
4. **性能代价：** 停等协议简单但效率低，每次只能发送一个数据包
5. **实际应用局限：** 适合小数据量传输，大数据传输需要更高效的协议（如滑动窗口）

## 九、详细注释源程序

### 9.1 服务器端源程序（server.cpp）

```cpp
#include <iostream>
#include <winsock2.h>      // Windows Socket API
#include <ws2tcpip.h>      // IP地址转换函数
#include <string>
#include <cstring>         // memcpy等字符串操作
#include <ctime>           // 时间函数
#pragma comment(lib, "ws2_32.lib")  // 链接Winsock库

using namespace std;

// ==================== 配置定义 ====================
#define SERVER_PORT 12340        // 服务器监听端口
#define BUFFER_SIZE 1024         // 缓冲区大小
#define TIMEOUT_MS 2000          // 超时时间2秒

// ==================== 数据结构定义 ====================
/**
 * @brief 数据帧结构
 * 用于封装发送的数据，包含序列号、数据内容和标志位
 */
struct DataFrame {
    unsigned char seq;      // 序列号 (0或1) - 用于停等协议的交替比特
    char data[BUFFER_SIZE]; // 数据内容 - 实际传输的数据
    unsigned char flag;     // 标志位: 0=普通数据帧, 1=结束帧
};

/**
 * @brief ACK确认帧结构
 * 用于确认数据帧的接收
 */
struct AckFrame {
    unsigned char ack;      // ACK序列号 - 对应要确认的数据帧序列号
};

// ==================== 全局变量 ====================
float ackLossRate = 0.0f;   // ACK丢包率，用于模拟网络不可靠性

// ==================== 辅助函数 ====================
/**
 * @brief 模拟ACK丢包
 * 根据设置的丢包率，使用随机数判断是否模拟ACK丢失
 * @return true表示模拟丢失，false表示不丢失
 */
bool simulateAckLoss() {
    if (ackLossRate <= 0.0f) return false;  // 丢包率为0则不丢包
    float random = (float)rand() / RAND_MAX;  // 生成0到1之间的随机数
    return random < ackLossRate;  // 随机数小于丢包率则判定为丢包
}

/**
 * @brief 获取当前时间字符串
 * @return 格式化的时间字符串
 */
string getCurrentTime() {
    time_t now = time(0);           // 获取当前时间戳
    char* dt = ctime(&now);         // 转换为可读字符串
    string timeStr(dt);
    timeStr.pop_back();             // 移除末尾换行符
    return timeStr;
}

// ==================== 核心函数 ====================
/**
 * @brief 发送数据帧并等待ACK（停等协议核心函数）
 *
 * 实现停等协议的发送端逻辑：
 * 1. 发送数据帧
 * 2. 等待ACK（设置超时）
 * 3. 收到正确ACK则返回成功
 * 4. 超时或收到错误ACK则重传
 * 5. 达到最大重传次数则返回失败
 *
 * @param sock 套接字
 * @param clientAddr 客户端地址结构
 * @param frame 要发送的数据帧
 * @param expectedAck 期望收到的ACK序列号
 * @param isLastFrame 是否是最后一个数据帧（最后一帧不模拟ACK丢失）
 * @return true表示发送成功，false表示失败
 */
bool sendDataFrame(SOCKET sock, sockaddr_in& clientAddr, DataFrame& frame,
                   int expectedAck, bool isLastFrame = false) {
    char buffer[sizeof(DataFrame)];           // 数据帧缓冲区
    memcpy(buffer, &frame, sizeof(DataFrame)); // 将结构体复制到缓冲区

    int attempts = 0;                         // 重传次数计数器
    const int MAX_ATTEMPTS = 5;               // 最大重传次数

    // 重传循环：最多尝试MAX_ATTEMPTS次
    while (attempts < MAX_ATTEMPTS) {
        // ========== 步骤1: 发送数据帧 ==========
        int sendResult = sendto(sock, buffer, sizeof(DataFrame), 0,
                               (sockaddr*)&clientAddr, sizeof(clientAddr));

        if (sendResult == SOCKET_ERROR) {
            cout << "[错误] 发送数据失败" << endl;
            return false;
        }

        cout << "[发送] Seq=" << (int)frame.seq
             << ", 数据大小=" << strlen(frame.data)
             << " 字节, 尝试次数=" << (attempts + 1) << endl;

        // ========== 步骤2: 准备接收ACK ==========
        sockaddr_in fromAddr;                 // 发送方地址
        int fromLen = sizeof(fromAddr);
        AckFrame ackFrame;                    // ACK帧

        // 使用select实现超时等待
        fd_set readSet;                       // 读文件描述符集合
        FD_ZERO(&readSet);                    // 清空集合
        FD_SET(sock, &readSet);               // 将套接字加入集合

        timeval timeout;                      // 超时结构体
        timeout.tv_sec = TIMEOUT_MS / 1000;   // 秒部分
        timeout.tv_usec = (TIMEOUT_MS % 1000) * 1000;  // 微秒部分

        // ========== 步骤3: 等待ACK（带超时） ==========
        // select监视套接字是否可读，最多等待timeout时间
        int selectResult = select(0, &readSet, NULL, NULL, &timeout);

        if (selectResult > 0) {
            // ========== 情况1: 有数据可读，接收ACK ==========
            int recvLen = recvfrom(sock, (char*)&ackFrame, sizeof(AckFrame), 0,
                                  (sockaddr*)&fromAddr, &fromLen);

            if (recvLen > 0) {
                cout << "[接收] ACK=" << (int)ackFrame.ack << endl;

                // ========== 步骤4: 模拟ACK丢失 ==========
                // 注意：最后一个数据包不模拟ACK丢失，因为客户端已经结束接收
                if (!isLastFrame && simulateAckLoss()) {
                    cout << "[模拟] ACK丢失! 假装未收到ACK" << endl;
                    attempts++;  // 计入重传次数
                    continue;    // 继续下一次循环，触发重传
                }

                // ========== 步骤5: 验证ACK序列号 ==========
                if (ackFrame.ack == expectedAck) {
                    cout << "[成功] 收到正确ACK" << endl;
                    return true;  // 成功，返回true
                } else {
                    cout << "[警告] ACK序列号不匹配, 期望=" << expectedAck
                         << ", 实际=" << (int)ackFrame.ack << endl;
                }
            }
        } else if (selectResult == 0) {
            // ========== 情况2: 超时，未收到ACK ==========
            cout << "[超时] 未收到ACK, 准备重传..." << endl;
        } else {
            // ========== 情况3: select调用失败 ==========
            cout << "[错误] select调用失败" << endl;
        }

        attempts++;  // 重传次数加1
    }

    // 达到最大重传次数，返回失败
    cout << "[失败] 达到最大重传次数" << endl;
    return false;
}

// ==================== 主函数 ====================
/**
 * @brief 服务器主函数
 *
 * 主要流程：
 * 1. 初始化Winsock
 * 2. 创建并绑定UDP套接字
 * 3. 设置ACK丢包率
 * 4. 进入主循环，处理客户端请求：
 *    - -time: 返回服务器时间
 *    - -quit: 发送Good bye消息
 *    - -test: 启动停等协议测试
 *    - 其他: 回显数据
 * 5. 清理资源
 */
int main() {
    srand((unsigned int)time(NULL));  // 初始化随机数种子

    // ==================== 1. 初始化Winsock ====================
    WSADATA wsaData;  // Winsock数据结构
    int result = WSAStartup(MAKEWORD(2, 2), &wsaData);  // 请求Winsock 2.2版本
    if (result != 0) {
        cout << "WSAStartup失败: " << result << endl;
        return 1;
    }

    // ==================== 2. 创建UDP套接字 ====================
    SOCKET serverSocket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    // AF_INET: IPv4地址族
    // SOCK_DGRAM: 数据报套接字（UDP）
    // IPPROTO_UDP: UDP协议
    if (serverSocket == INVALID_SOCKET) {
        cout << "创建socket失败: " << WSAGetLastError() << endl;
        WSACleanup();
        return 1;
    }

    // ==================== 3. 绑定地址和端口 ====================
    sockaddr_in serverAddr;              // 服务器地址结构
    serverAddr.sin_family = AF_INET;     // IPv4
    serverAddr.sin_addr.s_addr = INADDR_ANY;  // 监听所有网卡（0.0.0.0）
    serverAddr.sin_port = htons(SERVER_PORT);  // 端口号（转换为网络字节序）

    if (bind(serverSocket, (sockaddr*)&serverAddr, sizeof(serverAddr)) == SOCKET_ERROR) {
        cout << "绑定失败: " << WSAGetLastError() << endl;
        closesocket(serverSocket);
        WSACleanup();
        return 1;
    }

    // ==================== 4. 显示启动信息 ====================
    cout << "======================================" << endl;
    cout << "停等协议服务器已启动" << endl;
    cout << "监听端口: " << SERVER_PORT << endl;
    cout << "======================================" << endl;

    // ==================== 5. 设置ACK丢包率 ====================
    cout << "\n请输入ACK丢包率 (0.0-1.0, 默认0.2): ";
    string input;
    getline(cin, input);

    if (!input.empty()) {
        try {
            ackLossRate = stof(input);  // 字符串转浮点数
            if (ackLossRate < 0.0f) ackLossRate = 0.0f;  // 限制范围
            if (ackLossRate > 1.0f) ackLossRate = 1.0f;
        } catch (...) {
            cout << "[警告] 无效的丢包率, 使用默认值0.2" << endl;
            ackLossRate = 0.2f;
        }
    } else {
        ackLossRate = 0.2f;  // 默认值
    }

    cout << "\n[配置] ACK模拟丢包率: " << (ackLossRate * 100) << "%" << endl;
    cout << "======================================" << endl;

    // ==================== 6. 主循环：处理客户端请求 ====================
    while (true) {
        char recvBuffer[BUFFER_SIZE];    // 接收缓冲区
        sockaddr_in clientAddr;          // 客户端地址
        int clientAddrLen = sizeof(clientAddr);

        cout << "\n等待客户端请求..." << endl;

        // 接收客户端数据
        int recvLen = recvfrom(serverSocket, recvBuffer, BUFFER_SIZE, 0,
                              (sockaddr*)&clientAddr, &clientAddrLen);

        if (recvLen > 0) {
            recvBuffer[recvLen] = '\0';  // 添加字符串结束符
            string command(recvBuffer);  // 转换为C++字符串

            // 获取并显示客户端IP地址
            char clientIP[INET_ADDRSTRLEN];
            inet_ntop(AF_INET, &(clientAddr.sin_addr), clientIP, INET_ADDRSTRLEN);

            cout << "[请求] 来自 " << clientIP << ":" << ntohs(clientAddr.sin_port)
                 << " - " << command << endl;

            // ==================== 处理不同命令 ====================
            if (command == "-time") {
                // ========== 命令1: 返回服务器时间 ==========
                string timeStr = getCurrentTime();
                sendto(serverSocket, timeStr.c_str(), timeStr.length(), 0,
                      (sockaddr*)&clientAddr, clientAddrLen);
                cout << "[响应] 发送时间: " << timeStr << endl;
            }
            else if (command == "-quit") {
                // ========== 命令2: 客户端退出 ==========
                string goodbye = "Good bye!";
                sendto(serverSocket, goodbye.c_str(), goodbye.length(), 0,
                      (sockaddr*)&clientAddr, clientAddrLen);
                cout << "[响应] 客户端断开连接" << endl;
            }
            else if (command == "-test") {
                // ========== 命令3: 测试停等协议 ==========
                cout << "\n[开始] 停等协议数据传输测试" << endl;
                cout << "======================================" << endl;

                // 准备测试数据（5个数据包）
                const char* testData[] = {
                    "这是第一个数据包",
                    "这是第二个数据包",
                    "这是第三个数据包",
                    "停等协议测试数据",
                    "最后一个数据包"
                };
                int dataCount = 5;

                // 使用停等协议发送数据
                unsigned char currentSeq = 0;  // 当前序列号（从0开始）
                bool success = true;

                // 遍历所有数据包
                for (int i = 0; i < dataCount; i++) {
                    DataFrame frame;                    // 构建数据帧
                    frame.seq = currentSeq;             // 设置序列号
                    strcpy_s(frame.data, testData[i]);  // 复制数据
                    frame.flag = (i == dataCount - 1) ? 1 : 0;  // 最后一帧设置flag=1
                    bool isLastFrame = (i == dataCount - 1);

                    cout << "\n--- 发送数据包 " << (i + 1) << "/" << dataCount << " ---" << endl;

                    // 调用sendDataFrame发送数据帧并等待ACK
                    if (!sendDataFrame(serverSocket, clientAddr, frame, currentSeq, isLastFrame)) {
                        cout << "[失败] 数据包发送失败" << endl;
                        success = false;
                        break;
                    }

                    // 切换序列号（0->1, 1->0）
                    currentSeq = 1 - currentSeq;
                }

                // 显示传输结果
                cout << "\n======================================" << endl;
                if (success) {
                    cout << "[完成] 所有数据包已成功发送" << endl;
                } else {
                    cout << "[失败] 数据传输失败" << endl;
                }
                cout << "======================================" << endl;
            }
            else {
                // ========== 命令4: 回显数据 ==========
                sendto(serverSocket, recvBuffer, recvLen, 0,
                      (sockaddr*)&clientAddr, clientAddrLen);
                cout << "[响应] 回显数据: " << command << endl;
            }
        }
    }

    // ==================== 7. 清理资源 ====================
    closesocket(serverSocket);  // 关闭套接字
    WSACleanup();               // 清理Winsock

    return 0;
}
```

### 9.2 客户端源程序（client.cpp）

```cpp
#include <iostream>
#include <winsock2.h>      // Windows Socket API
#include <ws2tcpip.h>      // IP地址转换函数
#include <string>
#include <cstring>
#include <cstdlib>
#include <ctime>
#pragma comment(lib, "ws2_32.lib")  // 链接Winsock库

using namespace std;

// ==================== 配置定义 ====================
#define SERVER_PORT 12340        // 服务器端口
#define SERVER_IP "127.0.0.1"    // 服务器IP地址（本地回环）
#define BUFFER_SIZE 1024         // 缓冲区大小

// ==================== 数据结构定义 ====================
/**
 * @brief 数据帧结构（与服务器端一致）
 */
struct DataFrame {
    unsigned char seq;      // 序列号 (0或1)
    char data[BUFFER_SIZE]; // 数据内容
    unsigned char flag;     // 标志位: 0=数据帧, 1=结束帧
};

/**
 * @brief ACK确认帧结构（与服务器端一致）
 */
struct AckFrame {
    unsigned char ack;      // ACK序列号
};

// ==================== 全局变量 ====================
float lossRate = 0.0f;      // 数据包丢包率
float ackLossRate = 0.0f;   // ACK丢包率

// ==================== 辅助函数 ====================
/**
 * @brief 模拟数据包丢包
 * @return true表示模拟丢失，false表示不丢失
 */
bool simulateLoss() {
    if (lossRate <= 0.0f) return false;
    float random = (float)rand() / RAND_MAX;
    return random < lossRate;
}

/**
 * @brief 模拟ACK丢包
 * @return true表示模拟丢失，false表示不丢失
 */
bool simulateAckLoss() {
    if (ackLossRate <= 0.0f) return false;
    float random = (float)rand() / RAND_MAX;
    return random < ackLossRate;
}

// ==================== 主函数 ====================
/**
 * @brief 客户端主函数
 *
 * 主要流程：
 * 1. 初始化Winsock
 * 2. 创建UDP套接字
 * 3. 设置服务器地址
 * 4. 显示命令菜单
 * 5. 进入主循环，处理用户命令：
 *    - -time: 请求服务器时间
 *    - -quit: 退出程序
 *    - -test [数据丢包率] [ACK丢包率]: 测试停等协议
 *    - 其他: 回显测试
 * 6. 清理资源
 */
int main() {
    srand((unsigned int)time(NULL));  // 初始化随机数种子

    // ==================== 1. 初始化Winsock ====================
    WSADATA wsaData;
    int result = WSAStartup(MAKEWORD(2, 2), &wsaData);
    if (result != 0) {
        cout << "WSAStartup失败: " << result << endl;
        return 1;
    }

    // ==================== 2. 创建UDP套接字 ====================
    SOCKET clientSocket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if (clientSocket == INVALID_SOCKET) {
        cout << "创建socket失败: " << WSAGetLastError() << endl;
        WSACleanup();
        return 1;
    }

    // ==================== 3. 设置服务器地址 ====================
    sockaddr_in serverAddr;
    serverAddr.sin_family = AF_INET;
    serverAddr.sin_port = htons(SERVER_PORT);  // 端口号转网络字节序
    inet_pton(AF_INET, SERVER_IP, &serverAddr.sin_addr);  // IP字符串转二进制

    // ==================== 4. 显示命令菜单 ====================
    cout << "======================================" << endl;
    cout << "停等协议客户端" << endl;
    cout << "服务器地址: " << SERVER_IP << ":" << SERVER_PORT << endl;
    cout << "======================================" << endl;
    cout << "\n可用命令:" << endl;
    cout << "  -time                          获取服务器时间" << endl;
    cout << "  -test [数据丢包率] [ACK丢包率]  测试停等协议" << endl;
    cout << "                                 丢包率范围0.0-1.0" << endl;
    cout << "                                 默认: 数据丢包率=0.2, ACK丢包率=0.1" << endl;
    cout << "  -quit                          退出程序" << endl;
    cout << "  其他文本                        回显测试" << endl;
    cout << "======================================\n" << endl;

    // ==================== 5. 主循环：处理用户命令 ====================
    while (true) {
        cout << "\n请输入命令: ";
        string input;
        getline(cin, input);

        if (input.empty()) continue;  // 空输入，继续等待

        // ==================== 解析并处理命令 ====================
        if (input == "-time") {
            // ========== 命令1: 请求服务器时间 ==========
            sendto(clientSocket, input.c_str(), input.length(), 0,
                  (sockaddr*)&serverAddr, sizeof(serverAddr));

            char recvBuffer[BUFFER_SIZE];
            sockaddr_in fromAddr;
            int fromLen = sizeof(fromAddr);

            int recvLen = recvfrom(clientSocket, recvBuffer, BUFFER_SIZE, 0,
                                  (sockaddr*)&fromAddr, &fromLen);

            if (recvLen > 0) {
                recvBuffer[recvLen] = '\0';
                cout << "[服务器时间] " << recvBuffer << endl;
            }
        }
        else if (input == "-quit") {
            // ========== 命令2: 退出程序 ==========
            sendto(clientSocket, input.c_str(), input.length(), 0,
                  (sockaddr*)&serverAddr, sizeof(serverAddr));

            char recvBuffer[BUFFER_SIZE];
            sockaddr_in fromAddr;
            int fromLen = sizeof(fromAddr);

            int recvLen = recvfrom(clientSocket, recvBuffer, BUFFER_SIZE, 0,
                                  (sockaddr*)&fromAddr, &fromLen);

            if (recvLen > 0) {
                recvBuffer[recvLen] = '\0';
                cout << "[服务器] " << recvBuffer << endl;
            }

            break;  // 退出循环
        }
        else if (input.substr(0, 5) == "-test") {
            // ========== 命令3: 测试停等协议 ==========

            // ---------- 3.1 解析丢包率参数 ----------
            lossRate = 0.2f;      // 默认数据丢包率
            ackLossRate = 0.1f;   // 默认ACK丢包率

            if (input.length() > 6) {
                size_t firstSpace = input.find(' ', 6);
                size_t secondSpace = input.find(' ', firstSpace + 1);

                // 解析第一个参数（数据丢包率）
                try {
                    string firstParam = (secondSpace != string::npos)
                        ? input.substr(6, secondSpace - 6)
                        : input.substr(6);
                    lossRate = stof(firstParam);
                    if (lossRate < 0.0f) lossRate = 0.0f;
                    if (lossRate > 1.0f) lossRate = 1.0f;
                } catch (...) {
                    cout << "[警告] 无效的数据丢包率, 使用默认值0.2" << endl;
                    lossRate = 0.2f;
                }

                // 解析第二个参数（ACK丢包率）
                if (secondSpace != string::npos && secondSpace + 1 < input.length()) {
                    try {
                        string secondParam = input.substr(secondSpace + 1);
                        ackLossRate = stof(secondParam);
                        if (ackLossRate < 0.0f) ackLossRate = 0.0f;
                        if (ackLossRate > 1.0f) ackLossRate = 1.0f;
                    } catch (...) {
                        cout << "[警告] 无效的ACK丢包率, 使用默认值0.1" << endl;
                        ackLossRate = 0.1f;
                    }
                }
            }

            cout << "\n[开始] 停等协议测试" << endl;
            cout << "数据包丢包率: " << (lossRate * 100) << "%" << endl;
            cout << "ACK丢包率: " << (ackLossRate * 100) << "%" << endl;
            cout << "======================================" << endl;

            // ---------- 3.2 发送测试命令 ----------
            string testCmd = "-test";
            sendto(clientSocket, testCmd.c_str(), testCmd.length(), 0,
                  (sockaddr*)&serverAddr, sizeof(serverAddr));

            // ---------- 3.3 接收数据（停等协议接收端） ----------
            unsigned char expectedSeq = 0;  // 期望的序列号（初始为0）
            int receivedCount = 0;          // 成功接收数据包计数
            int duplicateCount = 0;         // 重复数据包计数

            // 接收循环
            while (true) {
                DataFrame frame;
                sockaddr_in fromAddr;
                int fromLen = sizeof(fromAddr);

                // 设置接收超时（10秒）
                DWORD timeout = 10000;
                setsockopt(clientSocket, SOL_SOCKET, SO_RCVTIMEO,
                          (char*)&timeout, sizeof(timeout));

                // 接收数据帧
                int recvLen = recvfrom(clientSocket, (char*)&frame, sizeof(DataFrame), 0,
                                      (sockaddr*)&fromAddr, &fromLen);

                if (recvLen > 0) {
                    // ===== 成功接收数据帧 =====
                    cout << "\n[接收] Seq=" << (int)frame.seq
                         << ", 数据=\"" << frame.data << "\"" << endl;

                    // ===== 步骤1: 模拟数据包丢失 =====
                    if (simulateLoss()) {
                        cout << "[模拟] 数据包丢失! 不发送ACK" << endl;
                        continue;  // 不发送ACK，继续接收下一个数据帧
                    }

                    // ===== 步骤2: 检查序列号 =====
                    if (frame.seq == expectedSeq) {
                        // ----- 情况1: 序列号匹配（正确的数据帧） -----
                        cout << "[正确] 序列号匹配, 准备发送ACK=" << (int)expectedSeq << endl;

                        // 模拟ACK丢失
                        if (simulateAckLoss()) {
                            cout << "[模拟] ACK丢失! 不发送ACK" << endl;
                            continue;  // 不发送ACK
                        }

                        // 发送ACK
                        AckFrame ackFrame;
                        ackFrame.ack = expectedSeq;
                        sendto(clientSocket, (char*)&ackFrame, sizeof(AckFrame), 0,
                              (sockaddr*)&serverAddr, sizeof(serverAddr));
                        cout << "[发送] ACK=" << (int)expectedSeq << endl;

                        receivedCount++;  // 成功接收计数

                        // 更新期望的序列号（0->1, 1->0）
                        expectedSeq = 1 - expectedSeq;

                        // ===== 步骤3: 检查是否为最后一帧 =====
                        if (frame.flag == 1) {
                            cout << "\n[完成] 收到结束标志, 传输完成!" << endl;
                            cout << "======================================" << endl;
                            cout << "统计信息:" << endl;
                            cout << "  成功接收数据包: " << receivedCount << " 个" << endl;
                            cout << "  重复数据包: " << duplicateCount << " 个" << endl;
                            cout << "======================================" << endl;
                            break;  // 退出接收循环
                        }
                    } else {
                        // ----- 情况2: 序列号不匹配（重复的数据帧） -----
                        cout << "[重复] 序列号不匹配! 期望=" << (int)expectedSeq
                             << ", 实际=" << (int)frame.seq << endl;
                        cout << "[重复] 这是重复的数据包, 丢弃数据" << endl;

                        duplicateCount++;  // 重复数据包计数

                        // 模拟ACK丢失
                        if (simulateAckLoss()) {
                            cout << "[模拟] ACK丢失! 不重发ACK" << endl;
                            continue;
                        }

                        cout << "[重发] 重发上一个ACK=" << (int)(1 - expectedSeq) << endl;

                        // 重发上一个ACK（因为当前帧是重复的）
                        AckFrame ackFrame;
                        ackFrame.ack = 1 - expectedSeq;  // 上一个序列号
                        sendto(clientSocket, (char*)&ackFrame, sizeof(AckFrame), 0,
                              (sockaddr*)&serverAddr, sizeof(serverAddr));
                    }
                } else if (recvLen == SOCKET_ERROR) {
                    // ===== 接收错误或超时 =====
                    int error = WSAGetLastError();
                    if (error == WSAETIMEDOUT) {
                        cout << "\n[超时] 未收到更多数据, 测试结束" << endl;
                        cout << "======================================" << endl;
                        cout << "统计信息:" << endl;
                        cout << "  成功接收数据包: " << receivedCount << " 个" << endl;
                        cout << "  重复数据包: " << duplicateCount << " 个" << endl;
                        cout << "======================================" << endl;
                        break;
                    } else {
                        cout << "[错误] 接收失败: " << error << endl;
                        break;
                    }
                }
            }

            cout << "======================================" << endl;
        }
        else {
            // ========== 命令4: 回显测试 ==========
            sendto(clientSocket, input.c_str(), input.length(), 0,
                  (sockaddr*)&serverAddr, sizeof(serverAddr));

            char recvBuffer[BUFFER_SIZE];
            sockaddr_in fromAddr;
            int fromLen = sizeof(fromAddr);

            int recvLen = recvfrom(clientSocket, recvBuffer, BUFFER_SIZE, 0,
                                  (sockaddr*)&fromAddr, &fromLen);

            if (recvLen > 0) {
                recvBuffer[recvLen] = '\0';
                cout << "[回显] " << recvBuffer << endl;
            }
        }
    }

    // ==================== 6. 清理资源 ====================
    closesocket(clientSocket);  // 关闭套接字
    WSACleanup();               // 清理Winsock

    cout << "\n客户端已关闭" << endl;

    return 0;
}
```

## 十、实验心得与总结

### 10.1 主要收获

1. **深入理解停等协议：**
   - 掌握了停等协议的工作原理和交替比特机制
   - 理解了序列号、确认、超时重传等核心概念
   - 认识到停等协议的简单性和效率局限性

2. **UDP编程实践：**
   - 熟悉了UDP Socket编程的基本API
   - 掌握了无连接通信的特点和编程模式
   - 学会了使用select和setsockopt实现超时控制

3. **可靠传输机制：**
   - 理解了如何在不可靠信道上实现可靠传输
   - 掌握了超时重传、重复检测、顺序控制等技术
   - 认识到应用层协议设计的重要性

4. **网络编程调试：**
   - 学会了使用丢包模拟验证协议正确性
   - 掌握了网络程序的调试和测试方法
   - 理解了异常场景的处理重要性

### 10.2 遇到的问题及解决

1. **问题：ACK丢失导致死锁**
   - 原因：最后一个数据包的ACK丢失后，服务器重传，但客户端已退出接收循环
   - 解决：最后一个数据包不模拟ACK丢失（`!isLastFrame`条件）

2. **问题：重复数据包处理不当**
   - 原因：初始时未正确重发上一个ACK
   - 解决：收到重复数据包时，重发`ACK(1-expectedSeq)`

3. **问题：超时时间设置不合理**
   - 原因：超时时间过短导致误判，过长影响测试效率
   - 解决：经过测试确定2秒超时时间较为合适

### 10.3 改进方向

1. **性能优化：**
   - 可以实现滑动窗口协议（如Go-Back-N或Selective Repeat）提高传输效率
   - 使用流水线技术允许多个数据包同时在传输

2. **功能扩展：**
   - 添加文件传输功能
   - 实现更复杂的错误检测（如CRC校验）
   - 支持大数据包的分片和重组

3. **鲁棒性增强：**
   - 增加异常处理机制
   - 实现连接管理（握手和挥手）
   - 添加日志记录功能

### 10.4 实验总结

本实验成功实现了基于UDP的停等协议，验证了在不可靠信道上实现可靠数据传输的可行性。通过丢包模拟和各种测试场景，深入理解了停等协议的工作机制和局限性。实验不仅巩固了网络编程的基础知识，也为后续学习更高效的传输协议（如滑动窗口协议）奠定了基础。

停等协议虽然简单，但在实际应用中效率较低，仅适用于小数据量传输或对实时性要求不高的场景。现代网络协议（如TCP）采用了更复杂的机制来平衡可靠性和效率。

---

**实验完成日期：** 2025年10月23日

**作者：** [您的姓名]

**课程：** 计算机网络实验

**实验编号：** Lab2-1
